"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _radium = require("radium");

var _radium2 = _interopRequireDefault(_radium);

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _d3Scale = require("d3-scale");

var _d3Scale2 = _interopRequireDefault(_d3Scale);

var _point = require("./point");

var _point2 = _interopRequireDefault(_point);

var _victoryUtil = require("victory-util");

var _victoryUtil2 = _interopRequireDefault(_victoryUtil);

var _victoryAnimation = require("victory-animation");

var defaultStyles = {
  data: {
    fill: "#756f6a",
    opacity: 1,
    stroke: "transparent",
    strokeWidth: 0
  },
  labels: {
    stroke: "transparent",
    fill: "#756f6a",
    fontFamily: "Helvetica",
    fontSize: 10,
    textAnchor: "middle",
    padding: 5
  }
};

var VictoryScatter = (function (_React$Component) {
  _inherits(VictoryScatter, _React$Component);

  function VictoryScatter() {
    _classCallCheck(this, _VictoryScatter);

    _get(Object.getPrototypeOf(_VictoryScatter.prototype), "constructor", this).apply(this, arguments);
  }

  _createClass(VictoryScatter, [{
    key: "getCalculatedValues",
    value: function getCalculatedValues(props) {
      this.style = this.getStyles(props);
      this.padding = this.getPadding(props);
      this.range = {
        x: this.getRange(props, "x"),
        y: this.getRange(props, "y")
      };
      this.data = this.getData(props);
      this.domain = {
        x: this.getDomain(props, "x"),
        y: this.getDomain(props, "y")
      };
      this.scale = {
        x: this.getScale(props, "x"),
        y: this.getScale(props, "y")
      };
    }
  }, {
    key: "getStyles",
    value: function getStyles(props) {
      var style = props.style || defaultStyles;
      var data = style.data;
      var labels = style.labels;
      var parent = style.parent;

      return {
        parent: _lodash2["default"].merge({ height: props.height, width: props.width }, parent),
        labels: _lodash2["default"].merge({}, defaultStyles.labels, labels),
        data: _lodash2["default"].merge({}, defaultStyles.data, data)
      };
    }
  }, {
    key: "getPadding",
    value: function getPadding(props) {
      var padding = _lodash2["default"].isNumber(props.padding) ? props.padding : 0;
      var paddingObj = _lodash2["default"].isObject(props.padding) ? props.padding : {};
      return {
        top: paddingObj.top || padding,
        bottom: paddingObj.bottom || padding,
        left: paddingObj.left || padding,
        right: paddingObj.right || padding
      };
    }
  }, {
    key: "getScale",
    value: function getScale(props, axis) {
      var scale = undefined;
      if (props.scale && props.scale[axis]) {
        scale = props.scale[axis].copy();
      } else if (props.scale && !_lodash2["default"].isObject(props.scale)) {
        scale = props.scale.copy();
      } else {
        scale = _d3Scale2["default"].linear().copy();
      }
      var range = this.range[axis];
      var domain = this.domain[axis];
      scale.range(range);
      scale.domain(domain);
      return scale;
    }
  }, {
    key: "getRange",
    value: function getRange(props, axis) {
      // if the range is not given in props, calculate it from width, height and margin
      return axis === "x" ? [this.padding.left, props.width - this.padding.right] : [props.height - this.padding.bottom, this.padding.top];
    }
  }, {
    key: "getDomain",
    value: function getDomain(props, axis) {
      if (props.domain && props.domain[axis]) {
        return props.domain[axis];
      } else if (props.domain && !_lodash2["default"].isObject(props.domain)) {
        return props.domain;
      } else {
        return [_lodash2["default"].min(_lodash2["default"].pluck(this.data, axis)), _lodash2["default"].max(_lodash2["default"].pluck(this.data, axis))];
      }
    }
  }, {
    key: "getData",
    value: function getData(props) {
      if (props.data) {
        return props.data;
      }
      var x = this.returnOrGenerateX(props);
      var y = this.returnOrGenerateY(props, x);
      var n = _lodash2["default"].min([x.length, y.length]);
      // create a dataset from x and y with n points
      var dataset = _lodash2["default"].zip(_lodash2["default"].take(x, n), _lodash2["default"].take(y, n));
      // return data as an array of objects
      return _lodash2["default"].map(dataset, function (point) {
        return { x: point[0], y: point[1] };
      });
    }
  }, {
    key: "returnOrGenerateX",
    value: function returnOrGenerateX(props) {
      if (props.x) {
        return props.x;
      }
      // if x is not given in props, create an array of values evenly
      // spaced across the x domain
      var domainFromProps = props.domain && props.domain.x || props.domain;
      var domainFromScale = props.scale && props.scale.x ? props.scale.x.domain() : props.scale.domain();
      var domain = domainFromProps || domainFromScale;

      var samples = _lodash2["default"].isArray(props.y) ? props.y.length : props.samples;
      var step = _lodash2["default"].max(domain) / samples;
      // return an array of x values spaced across the domain,
      // include the maximum of the domain
      return _lodash2["default"].union(_lodash2["default"].range(_lodash2["default"].min(domain), _lodash2["default"].max(domain), step), [_lodash2["default"].max(domain)]);
    }
  }, {
    key: "returnOrGenerateY",
    value: function returnOrGenerateY(props, x) {
      if (_lodash2["default"].isFunction(props.y)) {
        // if y is a function, apply the function y to to each value of the array x,
        // and return the results as an array
        return _lodash2["default"].map(x, function (datum) {
          return props.y(datum);
        });
      }
      // y is either a function or an array, and is never undefined
      // if it isn't a function, just return it.
      return props.y;
    }
  }, {
    key: "getSymbol",
    value: function getSymbol(data) {
      if (this.props.bubbleProperty) {
        return "circle";
      }
      return data.symbol || this.props.symbol;
    }
  }, {
    key: "getSize",
    value: function getSize(data) {
      var z = this.props.bubbleProperty;
      if (data.size) {
        return _lodash2["default"].isFunction(data.size) ? data.size : _lodash2["default"].max([data.size, 1]);
      } else if (_lodash2["default"].isFunction(this.props.size)) {
        return this.props.size;
      } else if (z && data[z]) {
        return this.getBubbleSize(data, z);
      } else {
        return _lodash2["default"].max([this.props.size, 1]);
      }
    }
  }, {
    key: "getBubbleSize",
    value: function getBubbleSize(datum, z) {
      var data = this.data;
      var zMin = _lodash2["default"].min(_lodash2["default"].pluck(data, z));
      var zMax = _lodash2["default"].max(_lodash2["default"].pluck(data, z));
      var maxRadius = this.props.maxBubbleSize || _lodash2["default"].max([_lodash2["default"].min(_lodash2["default"].values(this.padding)), 5]);
      var maxArea = Math.PI * Math.pow(maxRadius, 2);
      var area = (datum[z] - zMin) / (zMax - zMin) * maxArea;
      var radius = Math.sqrt(area / Math.PI);
      return _lodash2["default"].max([radius, 1]);
    }
  }, {
    key: "renderPoint",
    value: function renderPoint(data, index) {
      var position = {
        x: this.scale.x.call(this, data.x),
        y: this.scale.y.call(this, data.y)
      };
      var pointElement = _react2["default"].createElement(_point2["default"], {
        key: "point-" + index,
        labelComponent: this.props.labelComponent,
        showLabels: this.props.showLabels,
        style: this.style,
        x: position.x,
        y: position.y,
        data: data,
        size: this.getSize(data),
        symbol: this.getSymbol(data)
      });

      return pointElement;
    }
  }, {
    key: "renderData",
    value: function renderData() {
      var _this = this;

      return _lodash2["default"].map(this.data, function (dataPoint, index) {
        return _this.renderPoint(dataPoint, index);
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      // If animating, return a `VictoryAnimation` element that will create
      // a new `VictoryScatter` with nearly identical props, except (1) tweened
      // and (2) `animate` set to null so we don't recurse forever.
      if (this.props.animate) {
        // Do less work by having `VictoryAnimation` tween only values that
        // make sense to tween. In the future, allow customization of animated
        // prop whitelist/blacklist?
        var animateData = _lodash2["default"].pick(this.props, ["data", "domain", "height", "maxBubbleSize", "padding", "samples", "size", "style", "width", "x", "y"]);

        return _react2["default"].createElement(
          _victoryAnimation.VictoryAnimation,
          _extends({}, this.props.animate, { data: animateData }),
          function (props) {
            return _react2["default"].createElement(VictoryScatter, _extends({}, _this2.props, props, { animate: null }));
          }
        );
      } else {
        this.getCalculatedValues(this.props);
      }
      var style = this.style.parent;
      var group = _react2["default"].createElement(
        "g",
        { style: style },
        this.renderData()
      );
      return this.props.standalone ? _react2["default"].createElement(
        "svg",
        { style: style },
        group
      ) : group;
    }
  }], [{
    key: "role",
    value: "scatter",
    enumerable: true
  }, {
    key: "propTypes",
    value: {
      /**
       * The animate prop specifies props for victory-animation to use. It this prop is
       * not given, the scatter plot will not tween between changing data / style props.
       * Large datasets might animate slowly due to the inherent limits of svg rendering.
       * @examples {delay: 5, velocity: 0.02, onEnd: () => alert("woo!")}
       */
      animate: _react.PropTypes.object,
      /**
       * The bubbleProperty prop indicates which property of the data object should be used
       * to scale data points in a bubble chart
       */
      bubbleProperty: _react.PropTypes.string,
      /**
       * The data prop specifies the data to be plotted. Data should be in the form of an array
       * of data points where each data point should be an object with x and y properties.
       * Other properties may be added to the data point object, such as fill, size, and symbol.
       * These properties will be interpreted and applied to the individual lines
       * @examples [{x: 1, y: 2, fill: "red"}, {x: 2, y: 3, label: "foo"}]
       */
      data: _react.PropTypes.arrayOf(_react.PropTypes.shape({
        x: _react.PropTypes.any,
        y: _react.PropTypes.any
      })),
      /**
       * The domain prop describes the range of values your chart will include. This prop can be
       * given as a array of the minimum and maximum expected values for your chart,
       * or as an object that specifies separate arrays for x and y.
       * If this prop is not provided, a domain will be calculated from data, or other
       * available information.
       * @examples [-1, 1], {x: [0, 100], y: [0, 1]}
       */
      domain: _react.PropTypes.oneOfType([_victoryUtil2["default"].PropTypes.domain, _react.PropTypes.shape({
        x: _victoryUtil2["default"].PropTypes.domain,
        y: _victoryUtil2["default"].PropTypes.domain
      })]),
      /**
       * The height props specifies the height of the chart container element in pixels
       */
      height: _victoryUtil2["default"].PropTypes.nonNegative,
      /**
       * The labelComponent prop takes in an entire, HTML-complete label component
       * which will be used to create labels for scatter to use
       */
      labelComponent: _react.PropTypes.element,
      /**
       * The maxBubbleSize prop sets an upper limit for scaling data points in a bubble chart
       */
      maxBubbleSize: _victoryUtil2["default"].PropTypes.nonNegative,
      /**
       * The padding props specifies the amount of padding in number of pixels between
       * the edge of the chart and any rendered child components. This prop can be given
       * as a number or as an object with padding specified for top, bottom, left
       * and right.
       */
      padding: _react.PropTypes.oneOfType([_react.PropTypes.number, _react.PropTypes.shape({
        top: _react.PropTypes.number,
        bottom: _react.PropTypes.number,
        left: _react.PropTypes.number,
        right: _react.PropTypes.number
      })]),
      /**
       * The samples prop specifies how many individual points to plot when plotting
       * y as a function of x. Samples is ignored if x props are provided instead.
       */
      samples: _victoryUtil2["default"].PropTypes.nonNegative,
      /**
       * The scale prop determines which scales your chart should use. This prop can be
       * given as a function, or as an object that specifies separate functions for x and y.
       * @exampes d3Scale.time(), {x: d3Scale.linear(), y:tick d3Scale.log()}
       */
      scale: _react.PropTypes.oneOfType([_victoryUtil2["default"].PropTypes.scale, _react.PropTypes.shape({
        x: _victoryUtil2["default"].PropTypes.scale,
        y: _victoryUtil2["default"].PropTypes.scale
      })]),
      /**
       * The showLabels prop determines whether to show any labels associated with a data point.
       * Large datasets might animate slowly due to the inherent limits of svg rendering.
       * If animations are running slowly, try setting this prop to false to cut down on
       * the number of svg nodes
       */
      showLabels: _react.PropTypes.bool,
      /**
       * The size prop determines how to scale each data point
       */
      size: _react.PropTypes.oneOfType([_victoryUtil2["default"].PropTypes.nonNegative, _react.PropTypes.func]),
      /**
       * The standalone prop determines whether the component will render a standalone svg
       * or a <g> tag that will be included in an external svg. Set standalone to false to
       * compose VictoryScatter with other components within an enclosing <svg> tag.
       */
      standalone: _react.PropTypes.bool,
      /**
       * The style prop specifies styles for your scatter plot. VictoryScatter relies on Radium,
       * so valid Radium style objects should work for this prop. Height, width, and
       * padding should be specified via the height, width, and padding props, as they
       * are used to calculate the alignment of components within chart.
       * @examples {parent: {margin: 50}, data: {fill: "red"}, labels: {padding: 20}}
       */
      style: _react.PropTypes.shape({
        parent: _react.PropTypes.object,
        data: _react.PropTypes.object,
        labels: _react.PropTypes.object
      }),
      /**
       * The symbol prop determines which symbol should be drawn to represent data points.
       */
      symbol: _react.PropTypes.oneOfType([_react.PropTypes.oneOf(["circle", "diamond", "plus", "square", "star", "triangleDown", "triangleUp"]), _react.PropTypes.func]),
      /**
       * The width props specifies the width of the chart container element in pixels
       */
      width: _victoryUtil2["default"].PropTypes.nonNegative,
      /**
       * The x prop provides another way to supply data for scatter to plot. This prop can be given
       * as an array of values, and it will be plotted against whatever y prop is provided. If no
       * props are provided for y, the values in x will be plotted as the identity function.
       * @examples [1, 2, 3]
       */
      x: _victoryUtil2["default"].PropTypes.homogeneousArray,
      /**
       * The y prop provides another way to supply data for scatter to plot. This prop can be given
       * as a function of x, or an array of values. If x props are given, they will be used
       * in plotting (x, y) data points. If x props are not provided, a set of x values
       * evenly spaced across the x domain will be calculated, and used for plotting data points.
       * @examples (x) => Math.sin(x), [1, 2, 3]
       */
      y: _react.PropTypes.oneOfType([_react.PropTypes.array, _react.PropTypes.func])
    },
    enumerable: true
  }, {
    key: "defaultProps",
    value: {
      height: 300,
      padding: 50,
      samples: 50,
      scale: _d3Scale2["default"].linear(),
      showLabels: true,
      size: 3,
      standalone: true,
      symbol: "circle",
      width: 450,
      y: function y(x) {
        return x;
      }
    },
    enumerable: true
  }]);

  var _VictoryScatter = VictoryScatter;
  VictoryScatter = (0, _radium2["default"])(VictoryScatter) || VictoryScatter;
  return VictoryScatter;
})(_react2["default"].Component);

exports["default"] = VictoryScatter;
module.exports = exports["default"];