"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _radium = require("radium");

var _radium2 = _interopRequireDefault(_radium);

var _d3Shape = require("d3-shape");

var _d3Shape2 = _interopRequireDefault(_d3Shape);

var _victoryUtil = require("victory-util");

var _victoryUtil2 = _interopRequireDefault(_victoryUtil);

var _slice = require("./slice");

var _slice2 = _interopRequireDefault(_slice);

var _sliceLabel = require("./slice-label");

var _sliceLabel2 = _interopRequireDefault(_sliceLabel);

var _victoryAnimation = require("victory-animation");

var defaultStyles = {
  data: {
    padding: 5,
    stroke: "white",
    strokeWidth: 1
  },
  labels: {
    padding: 10,
    fill: "black",
    strokeWidth: 0,
    stroke: "transparent",
    fontFamily: "'Helvetica Neue', Helvetica, Arial, sans-serif",
    fontSize: 10,
    textAnchor: "middle"
  }
};

var VictoryPie = (function (_React$Component) {
  _inherits(VictoryPie, _React$Component);

  function VictoryPie() {
    _classCallCheck(this, _VictoryPie);

    _get(Object.getPrototypeOf(_VictoryPie.prototype), "constructor", this).apply(this, arguments);
  }

  _createClass(VictoryPie, [{
    key: "degreesToRadians",
    value: function degreesToRadians(degrees) {
      return degrees * (Math.PI / 180);
    }
  }, {
    key: "getCalculatedValues",
    value: function getCalculatedValues(props) {
      this.style = this.getStyles(props);
      this.padding = this.getPadding(props);
      this.radius = this.getRadius(props);
      this.colorScale = _lodash2["default"].isArray(props.colorScale) ? props.colorScale : _victoryUtil2["default"].Style.getColorScale(props.colorScale);
      this.slice = _d3Shape2["default"].arc().outerRadius(this.radius).innerRadius(this.props.innerRadius);
      this.labelPosition = this.getLabelPosition(props);
      this.pie = _d3Shape2["default"].pie().sort(null).startAngle(this.degreesToRadians(props.startAngle)).endAngle(this.degreesToRadians(props.endAngle)).padAngle(this.degreesToRadians(props.padAngle)).value(function (data) {
        return data.y;
      });
    }
  }, {
    key: "getStyles",
    value: function getStyles(props) {
      var style = props.style || defaultStyles;
      var data = style.data;
      var labels = style.labels;
      var parent = style.parent;

      return {
        parent: _lodash2["default"].merge({ height: props.height, width: props.width }, parent),
        data: _lodash2["default"].merge({}, defaultStyles.data, data),
        labels: _lodash2["default"].merge({}, defaultStyles.labels, labels)
      };
    }
  }, {
    key: "getPadding",
    value: function getPadding(props) {
      var padding = _lodash2["default"].isNumber(props.padding) ? props.padding : 0;
      var paddingObj = _lodash2["default"].isObject(props.padding) ? props.padding : {};
      return {
        top: paddingObj.top || padding,
        bottom: paddingObj.bottom || padding,
        left: paddingObj.left || padding,
        right: paddingObj.right || padding
      };
    }
  }, {
    key: "getRadius",
    value: function getRadius(props) {
      return _lodash2["default"].min([props.width - this.padding.left - this.padding.right, props.height - this.padding.top - this.padding.bottom]) / 2;
    }
  }, {
    key: "getLabelPosition",
    value: function getLabelPosition(props) {
      // TODO: better label positioning
      var innerRadius = props.innerRadius ? props.innerRadius + this.style.labels.padding : this.style.labels.padding;
      return _d3Shape2["default"].arc().outerRadius(this.radius).innerRadius(innerRadius);
    }
  }, {
    key: "renderData",
    value: function renderData() {
      var _this = this;

      var slices = this.pie(this.props.data);
      var sliceComponents = _lodash2["default"].map(slices, function (slice, index) {
        var fill = _this.colorScale[index % _this.colorScale.length];
        var style = _lodash2["default"].merge({}, _this.style.data, { fill: fill });
        return _react2["default"].createElement(
          "g",
          { key: index },
          _react2["default"].createElement(_slice2["default"], {
            slice: slice,
            pathFunction: _this.slice,
            style: style
          }),
          _react2["default"].createElement(_sliceLabel2["default"], {
            labelComponent: _this.props.labelComponent,
            style: _this.style.labels,
            positionFunction: _this.labelPosition.centroid,
            slice: slice
          })
        );
      });

      return _react2["default"].createElement(
        "g",
        null,
        sliceComponents
      );
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      if (this.props.animate) {
        // Do less work by having `VictoryAnimation` tween only values that
        // make sense to tween. In the future, allow customization of animated
        // prop whitelist/blacklist?
        var animateData = _lodash2["default"].pick(this.props, ["data", "endAngle", "height", "innerRadius", "padAngle", "padding", "colorScale", "startAngle", "style", "width"]);
        return _react2["default"].createElement(
          _victoryAnimation.VictoryAnimation,
          _extends({}, this.props.animate, { data: animateData }),
          function (props) {
            return _react2["default"].createElement(VictoryPie, _extends({}, _this2.props, props, { animate: null }));
          }
        );
      } else {
        this.getCalculatedValues(this.props);
      }
      var style = this.style.parent;
      var xOffset = this.radius + this.padding.left;
      var yOffset = this.radius + this.padding.top;
      var group = _react2["default"].createElement(
        "g",
        { style: style, transform: "translate(" + xOffset + ", " + yOffset + ")" },
        this.renderData()
      );

      return this.props.standalone ? _react2["default"].createElement(
        "svg",
        { style: style },
        group
      ) : group;
    }
  }], [{
    key: "propTypes",
    value: {
      /**
       * The animate prop specifies props for victory-animation to use. If this prop is
       * not given, the pie chart will not tween between changing data / style props.
       * Large datasets might animate slowly due to the inherent limits of svg rendering.
       * @examples {velocity: 0.02, onEnd: () => alert("done!")}
       */
      animate: _react.PropTypes.object,
      /**
       * The colorScale prop is an optional prop that defines the color scale the pie
       * will be created on. This prop should be given as an array of CSS colors, or as a string
       * corresponding to one of the built in color scales. VictoryPie will automatically assign
       * values from this color scale to the pie slices unless colors are explicitly provided in the
       * data object
       */
      colorScale: _react.PropTypes.oneOfType([_react.PropTypes.arrayOf(_react.PropTypes.string), _react.PropTypes.oneOf(["greyscale", "qualitative", "heatmap", "warm", "cool", "red", "green", "blue"])]),
      /**
       * Objects in the data array must be of the form { x: <x-val>, y: <y-val> }, where <x-val>
       * is the slice label (string or number), and <y-val> is the corresponding number
       * used to calculate arc length as a proportion of the pie's circumference.
       * If the data prop is omitted, the pie will render sample data.
       */
      data: _react.PropTypes.arrayOf(_react.PropTypes.shape({
        x: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),
        y: _react.PropTypes.number
      })),
      /**
       * The overall end angle of the pie in degrees. This prop is used in conjunction with
       * startAngle to create a pie that spans only a segment of a circle.
       */
      endAngle: _react.PropTypes.number,
      /**
       * The height props specifies the height of the chart container element in pixels
       */
      height: _victoryUtil2["default"].PropTypes.nonNegative,
      /**
       * When creating a donut chart, this prop determines the number of pixels between
       * the center of the chart and the inner edge of a donut. When this prop is set to zero
       * a regular pie chart is rendered.
       */
      innerRadius: _victoryUtil2["default"].PropTypes.nonNegative,
      /**
       * This prop specifies the labels that will be applied to your data. This prop can be
       * passed in as an array of values, in the same order as your data, or as a function
       * to be applied to each data point. If this prop is not specified, the x value
       * of each data point will be used as a label.
       */
      labelComponent: _react.PropTypes.element,
      /**
       * The padAngle prop determines the amount of separation between adjacent data slices
       * in number of degrees
       */
      padAngle: _victoryUtil2["default"].PropTypes.nonNegative,
      /**
       * The padding props specifies the amount of padding in number of pixels between
       * the edge of the chart and any rendered child components. This prop can be given
       * as a number or as an object with padding specified for top, bottom, left
       * and right.
       */
      padding: _react.PropTypes.oneOfType([_react.PropTypes.number, _react.PropTypes.shape({
        top: _react.PropTypes.number,
        bottom: _react.PropTypes.number,
        left: _react.PropTypes.number,
        right: _react.PropTypes.number
      })]),
      /**
       * The standalone prop determines whether VictoryPie should render as a standalone
       * svg, or in a g tag to be included in an svg
       */
      standalone: _react.PropTypes.bool,
      /**
       * The overall start angle of the pie in degrees. This prop is used in conjunction with
       * endAngle to create a pie that spans only a segment of a circle.
       */
      startAngle: _react.PropTypes.number,
      /**
       * The style prop specifies styles for your pie. VictoryPie relies on Radium,
       * so valid Radium style objects should work for this prop. Height, width, and
       * padding should be specified via the height, width, and padding props.
       * @examples {data: {stroke: "black"}, label: {fontSize: 10}}
       */
      style: _react.PropTypes.shape({
        parent: _react.PropTypes.object,
        data: _react.PropTypes.object,
        labels: _react.PropTypes.object
      }),
      /**
       * The width props specifies the width of the chart container element in pixels
       */
      width: _victoryUtil2["default"].PropTypes.nonNegative
    },
    enumerable: true
  }, {
    key: "defaultProps",
    value: {
      data: [{ x: "A", y: 1 }, { x: "B", y: 2 }, { x: "C", y: 3 }, { x: "D", y: 1 }, { x: "E", y: 2 }],
      endAngle: 360,
      height: 400,
      innerRadius: 0,
      padAngle: 0,
      padding: 30,
      colorScale: ["#75C776", "#39B6C5", "#78CCC4", "#62C3A4", "#64A8D1", "#8C95C8", "#3BAF74"],
      startAngle: 0,
      standalone: true,
      width: 400
    },
    enumerable: true
  }]);

  var _VictoryPie = VictoryPie;
  VictoryPie = (0, _radium2["default"])(VictoryPie) || VictoryPie;
  return VictoryPie;
})(_react2["default"].Component);

exports["default"] = VictoryPie;
module.exports = exports["default"];