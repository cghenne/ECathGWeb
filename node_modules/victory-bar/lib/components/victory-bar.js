"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _radium = require("radium");

var _radium2 = _interopRequireDefault(_radium);

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _d3Scale = require("d3-scale");

var _d3Scale2 = _interopRequireDefault(_d3Scale);

var _victoryUtil = require("victory-util");

var _victoryUtil2 = _interopRequireDefault(_victoryUtil);

var _victoryAnimation = require("victory-animation");

var _bar = require("./bar");

var _bar2 = _interopRequireDefault(_bar);

var _barLabel = require("./bar-label");

var _barLabel2 = _interopRequireDefault(_barLabel);

var defaultStyles = {
  data: {
    width: 8,
    padding: 6,
    stroke: "transparent",
    strokeWidth: 0,
    fill: "#756f6a",
    opacity: 1
  },
  labels: {
    fontSize: 12,
    padding: 4
  }
};

var defaultData = [{ x: 1, y: 1 }, { x: 2, y: 2 }, { x: 3, y: 3 }, { x: 4, y: 4 }];

var VictoryBar = (function (_React$Component) {
  _inherits(VictoryBar, _React$Component);

  function VictoryBar() {
    _classCallCheck(this, _VictoryBar);

    _get(Object.getPrototypeOf(_VictoryBar.prototype), "constructor", this).apply(this, arguments);
  }

  _createClass(VictoryBar, [{
    key: "getCalculatedValues",
    value: function getCalculatedValues(props) {
      this.style = this.getStyles(props);
      this.padding = this.getPadding(props);
      this.stringMap = {
        x: this.createStringMap(props, "x"),
        y: this.createStringMap(props, "y")
      };
      this.datasets = this.consolidateData(props);
      this.range = {
        x: this.getRange(props, "x"),
        y: this.getRange(props, "y")
      };
      this.domain = {
        x: this.getDomain(props, "x"),
        y: this.getDomain(props, "y")
      };
      this.scale = {
        x: this.getScale(props, "x"),
        y: this.getScale(props, "y")
      };
    }
  }, {
    key: "getStyles",
    value: function getStyles(props) {
      var style = props.style || defaultStyles;
      var data = style.data;
      var labels = style.labels;
      var parent = style.parent;

      return {
        parent: _lodash2["default"].merge({ height: props.height, width: props.width }, parent),
        data: _lodash2["default"].merge({}, defaultStyles.data, data),
        labels: _lodash2["default"].merge({}, defaultStyles.labels, labels)
      };
    }
  }, {
    key: "getPadding",
    value: function getPadding(props) {
      var padding = _lodash2["default"].isNumber(props.padding) ? props.padding : 0;
      var paddingObj = _lodash2["default"].isObject(props.padding) ? props.padding : {};
      return {
        top: paddingObj.top || padding,
        bottom: paddingObj.bottom || padding,
        left: paddingObj.left || padding,
        right: paddingObj.right || padding
      };
    }
  }, {
    key: "consolidateData",
    value: function consolidateData(props) {
      var _this = this;

      var dataFromProps = _lodash2["default"].isArray(props.data[0]) ? props.data : [props.data];
      return _lodash2["default"].map(dataFromProps, function (dataset, index) {
        return {
          attrs: _this.getAttributes(props, index),
          data: _lodash2["default"].map(dataset, function (data) {
            return _lodash2["default"].merge(data, {
              // determine category if it exists
              category: _this.determineCategoryIndex(data.x, props.categories),
              // map string data to numeric values, and add names
              x: _lodash2["default"].isString(data.x) ? _this.stringMap.x[data.x] : data.x,
              xName: _lodash2["default"].isString(data.x) ? data.x : undefined,
              y: _lodash2["default"].isString(data.y) ? _this.stringMap.y[data.y] : data.y,
              yName: _lodash2["default"].isString(data.y) ? data.y : undefined
            });
          })
        };
      });
    }
  }, {
    key: "determineCategoryIndex",
    value: function determineCategoryIndex(x, categories) {
      // if categories don't exist or are not given as an array of arrays, return undefined;
      if (!categories || !_lodash2["default"].isArray(categories[0])) {
        return undefined;
      }
      // determine which range band this x value belongs to, and return the index of that range band.
      return categories.findIndex(function (category) {
        return x >= Math.min.apply(Math, _toConsumableArray(category)) && x <= Math.max.apply(Math, _toConsumableArray(category));
      });
    }
  }, {
    key: "getAttributes",
    value: function getAttributes(props, index) {
      var attributes = props.dataAttributes && props.dataAttributes[index] ? props.dataAttributes[index] : props.dataAttributes;
      if (attributes) {
        attributes.fill = attributes.fill || this.getColor(props, index);
      } else {
        attributes = { fill: this.getColor(props, index) };
      }
      var requiredAttributes = {
        name: attributes && attributes.name ? attributes.name : "data-" + index
      };
      return _lodash2["default"].merge(requiredAttributes, attributes);
    }
  }, {
    key: "getColor",
    value: function getColor(props, index) {
      // check for styles first
      if (props.style && props.style.data && props.style.data.fill) {
        return props.style.data.fill;
      }
      var colorScale = _lodash2["default"].isArray(props.colorScale) ? props.colorScale : _victoryUtil2["default"].Style.getColorScale(props.colorScale);
      return colorScale[index % colorScale.length];
    }
  }, {
    key: "createStringMap",
    value: function createStringMap(props, axis) {
      // if categories exist and are strings, create a map using only those strings
      // don't alter the order.
      if (props.categories && _victoryUtil2["default"].Collection.containsStrings(props.categories)) {
        return _lodash2["default"].zipObject(_lodash2["default"].map(props.categories, function (tick, index) {
          return ["" + tick, index + 1];
        }));
      }
      // collect strings from data
      var data = _lodash2["default"].isArray(props.data) ? _lodash2["default"].flattenDeep(props.data) : props.data;
      // create a unique, sorted set of strings
      var stringData = _lodash2["default"].chain(data).pluck(axis).map(function (datum) {
        return _lodash2["default"].isString(datum) ? datum : null;
      }).compact().uniq().sort().value();

      return _lodash2["default"].isEmpty(stringData) ? null : _lodash2["default"].zipObject(_lodash2["default"].map(stringData, function (string, index) {
        return [string, index + 1];
      }));
    }
  }, {
    key: "getScale",
    value: function getScale(props, axis) {
      var scale = undefined;
      if (props.scale && props.scale[axis]) {
        scale = props.scale[axis].copy();
      } else if (props.scale && !_lodash2["default"].isObject(props.scale)) {
        scale = props.scale.copy();
      } else {
        scale = _d3Scale2["default"].linear().copy();
      }
      scale.range(this.range[axis]);
      scale.domain(this.domain[axis]);
      return scale;
    }
  }, {
    key: "getRange",
    value: function getRange(props, axis) {
      // determine how to lay the axis and what direction positive and negative are
      var isVertical = !this.props.horizontal && axis === "x" || this.props.horizontal && axis !== "x";

      return isVertical ? [this.padding.left, props.width - this.padding.right] : [props.height - this.padding.bottom, this.padding.top];
    }
  }, {
    key: "getDomain",
    value: function getDomain(props, axis) {
      var domain = undefined;
      var categoryDomain = this.getDomainFromCategories(props, axis);
      if (props.domain && props.domain[axis]) {
        domain = props.domain[axis];
      } else if (props.domain && _lodash2["default"].isArray(props.domain)) {
        domain = props.domain;
      } else if (categoryDomain) {
        domain = categoryDomain;
      } else {
        domain = this.getDomainFromData(props, axis);
      }
      return this.padDomain(domain, axis);
    }
  }, {
    key: "padDomain",
    value: function padDomain(domain, axis) {
      var domainPadding = undefined;
      if (this.props.domainPadding[axis]) {
        domainPadding = this.props.domainPadding[axis];
      } else {
        domainPadding = _lodash2["default"].isNumber(this.props.domainPadding) ? this.props.domainPadding : 0;
      }
      if (domainPadding === 0) {
        return domain;
      }
      var domainMin = Math.min.apply(Math, _toConsumableArray(domain));
      var domainMax = Math.max.apply(Math, _toConsumableArray(domain));
      var rangeExtent = Math.abs(Math.max.apply(Math, _toConsumableArray(this.range[axis])) - Math.min.apply(Math, _toConsumableArray(this.range[axis])));
      var extent = Math.abs(domainMax - domainMin);
      var percentPadding = domainPadding / rangeExtent;
      var padding = extent * percentPadding;
      // don't make the axes cross if they aren't already
      var adjustedMin = domainMin >= 0 && domainMin - padding <= 0 ? 0 : domainMin.valueOf() - padding;
      var adjustedMax = domainMax <= 0 && domainMax + padding >= 0 ? 0 : domainMax.valueOf() + padding;
      return _lodash2["default"].isDate(domainMin) || _lodash2["default"].isDate(domainMax) ? [new Date(adjustedMin), new Date(adjustedMax)] : [adjustedMin, adjustedMax];
    }
  }, {
    key: "getDomainFromCategories",
    value: function getDomainFromCategories(props, axis) {
      if (axis !== "x" || !props.categories || _victoryUtil2["default"].Collection.containsStrings(props.categories)) {
        return undefined;
      }
      var categories = _lodash2["default"].flatten(props.categories);
      return [Math.min.apply(Math, _toConsumableArray(categories)), Math.max.apply(Math, _toConsumableArray(categories))];
    }
  }, {
    key: "getDomainFromData",
    value: function getDomainFromData(props, axis) {
      // find the global min and max
      var datasets = this.datasets.map(function (dataset) {
        return dataset.data;
      });
      var axisData = _lodash2["default"].flatten(datasets).map(function (data) {
        return data[axis];
      });
      var globalMin = Math.min.apply(Math, _toConsumableArray(axisData));
      var globalMax = Math.max.apply(Math, _toConsumableArray(axisData));

      // find the cumulative max for stacked chart types
      // this is only sensible for the y domain
      // TODO check assumption
      var cumulativeData = props.stacked && axis === "y" && this.datasets.length > 1 ? this.getCumulativeData(datasets, "y") : [];

      var cumulativeMaxArray = cumulativeData.map(function (dataset) {
        return dataset.reduce(function (memo, val) {
          return val > 0 ? memo + val : memo;
        }, 0);
      });

      var cumulativeMinArray = cumulativeData.map(function (dataset) {
        return dataset.reduce(function (memo, val) {
          return val < 0 ? memo + val : memo;
        }, 0);
      });

      var cumulativeMin = Math.min.apply(Math, _toConsumableArray(cumulativeMinArray));
      // use greatest min / max
      var domainMin = cumulativeMin < 0 ? cumulativeMin : globalMin;
      var domainMax = Math.max(globalMax, Math.max.apply(Math, _toConsumableArray(cumulativeMaxArray)));
      return [domainMin, domainMax];
    }
  }, {
    key: "getCumulativeData",
    value: function getCumulativeData(datasets, axis) {
      var categories = [];
      var xValues = [];
      datasets.forEach(function (dataset) {
        dataset.forEach(function (data) {
          if (data.category !== undefined && !_lodash2["default"].includes(categories, data.category)) {
            categories.push(data.category);
          } else if (!_lodash2["default"].includes(xValues, data.x)) {
            xValues.push(data.x);
          }
        });
      });

      var dataByCategory = function dataByCategory() {
        return categories.map(function (value) {
          var categoryData = datasets.filter(function (data) {
            return data.category === value;
          });
          return _lodash2["default"].flatten(categoryData.map(function (data) {
            return data[axis];
          }));
        });
      };

      var dataByIndex = function dataByIndex() {
        return xValues.map(function (value, index) {
          return datasets.map(function (data) {
            return data[index] && data[index][axis];
          });
        });
      };

      return _lodash2["default"].isEmpty(categories) ? dataByIndex() : dataByCategory();
    }
  }, {
    key: "pixelsToValue",
    value: function pixelsToValue(pixels, axis) {
      var domainExtent = Math.max.apply(Math, _toConsumableArray(this.domain[axis])) - Math.min.apply(Math, _toConsumableArray(this.domain[axis]));
      var rangeExtent = Math.max.apply(Math, _toConsumableArray(this.range[axis])) - Math.min.apply(Math, _toConsumableArray(this.range[axis]));
      return domainExtent / rangeExtent * pixels;
    }
  }, {
    key: "adjustX",
    value: function adjustX(data, index, options) {
      var x = data.x;
      var stacked = options && options.stacked;
      var center = this.datasets.length % 2 === 0 ? this.datasets.length / 2 : (this.datasets.length - 1) / 2;
      var centerOffset = index - center;
      var totalWidth = this.pixelsToValue(this.style.data.padding, "x") + this.pixelsToValue(this.style.data.width, "x");
      if (data.category !== undefined) {
        // if this is category data, shift x to the center of its category
        var rangeBand = this.props.categories[data.category];
        var bandCenter = (Math.max.apply(Math, _toConsumableArray(rangeBand)) + Math.min.apply(Math, _toConsumableArray(rangeBand))) / 2;
        return stacked ? bandCenter : bandCenter + centerOffset * totalWidth;
      }
      return stacked ? x : x + centerOffset * totalWidth;
    }
  }, {
    key: "getYOffset",
    value: function getYOffset(data, index, barIndex) {
      var minY = Math.min.apply(Math, _toConsumableArray(this.domain.y));
      if (index === 0) {
        return Math.max(minY, 0);
      }
      var y = data.y;
      var previousDataSets = _lodash2["default"].take(this.datasets, index);
      var previousBars = _lodash2["default"].map(previousDataSets, function (dataset) {
        return _lodash2["default"].pluck(dataset.data, "y");
      });
      return _lodash2["default"].reduce(previousBars, function (memo, bar) {
        var barValue = bar[barIndex];
        var sameSign = y < 0 && barValue < 0 || y >= 0 && barValue >= 0;
        return sameSign ? memo + barValue : memo;
      }, 0);
    }
  }, {
    key: "getLabelIndex",
    value: function getLabelIndex(data) {
      if (data.category !== undefined) {
        return data.category;
      } else if (this.stringMap.x) {
        return data.x - 1;
      } else {
        var allX = this.datasets.map(function (dataset) {
          return dataset.data.map(function (datum) {
            return datum.x;
          });
        });
        var uniqueX = _lodash2["default"].uniq(_lodash2["default"].flatten(allX));
        return _lodash2["default"].findIndex(_lodash2["default"].sortBy(uniqueX), function (n) {
          return n === data.x;
        });
      }
    }
  }, {
    key: "getBarPosition",
    value: function getBarPosition(data, index, barIndex) {
      var stacked = this.props.stacked;
      var yOffset = this.getYOffset(data, index, barIndex);
      var y0 = stacked ? yOffset : Math.max(Math.min.apply(Math, _toConsumableArray(this.domain.y)), 0);
      var y1 = stacked ? yOffset + data.y : data.y;
      var x = this.adjustX(data, index, { stacked: stacked });
      return {
        independent: this.scale.x.call(this, x),
        dependent0: this.scale.y.call(this, y0),
        dependent1: this.scale.y.call(this, y1)
      };
    }
  }, {
    key: "renderBars",
    value: function renderBars(dataset, index) {
      var _this2 = this;

      var isCenter = Math.floor(this.datasets.length / 2) === index;
      var isLast = this.datasets.length === index + 1;
      var stacked = this.props.stacked;
      var plotGroupLabel = stacked && isLast || !stacked && isCenter;
      return _lodash2["default"].map(dataset.data, function (data, barIndex) {
        var position = _this2.getBarPosition(data, index, barIndex);
        var styleData = _lodash2["default"].omit(data, ["xName", "yName", "x", "y", "label", "category"]);
        var style = _lodash2["default"].merge({}, _this2.style.data, _lodash2["default"].omit(dataset.attrs, "name"), styleData);
        var barComponent = _react2["default"].createElement(_bar2["default"], { key: "series-" + index + "-bar-" + barIndex,
          horizontal: _this2.props.horizontal,
          style: style,
          position: position,
          data: data
        });
        var plotLabel = plotGroupLabel && (_this2.props.labels || _this2.props.labelComponents);
        if (plotLabel) {
          var labelIndex = _this2.getLabelIndex(data);
          var labelText = _this2.props.labels ? _this2.props.labels[labelIndex] || _this2.props.labels[0] : "";
          var labelComponent = _this2.props.labelComponents ? _this2.props.labelComponents[index] || _this2.props.labelComponents[0] : undefined;
          return _react2["default"].createElement(
            "g",
            { key: "series-" + index + "-bar-" + barIndex },
            barComponent,
            _react2["default"].createElement(_barLabel2["default"], { key: "label-series-" + index + "-bar-" + barIndex,
              horizontal: _this2.props.horizontal,
              style: _this2.style.labels,
              position: position,
              data: data,
              labelText: labelText,
              labelComponent: labelComponent
            })
          );
        }
        return barComponent;
      });
    }
  }, {
    key: "renderData",
    value: function renderData() {
      var _this3 = this;

      return _lodash2["default"].map(this.datasets, function (dataset, index) {
        return _this3.renderBars(dataset, index);
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      // If animating, return a `VictoryAnimation` element that will create
      // a new `VictoryBar` with nearly identical props, except (1) tweened
      // and (2) `animate` set to null so we don't recurse forever.
      if (this.props.animate) {
        // Do less work by having `VictoryAnimation` tween only values that
        // make sense to tween. In the future, allow customization of animated
        // prop whitelist/blacklist?
        var animateData = _lodash2["default"].pick(this.props, ["data", "dataAttributes", "categories", "colorScale", "domain", "height", "padding", "style", "width"]);
        return _react2["default"].createElement(
          _victoryAnimation.VictoryAnimation,
          _extends({}, this.props.animate, { data: animateData }),
          function (props) {
            return _react2["default"].createElement(VictoryBar, _extends({}, _this4.props, props, { animate: null }));
          }
        );
      } else {
        this.getCalculatedValues(this.props);
      }
      var style = this.style.parent;
      var group = _react2["default"].createElement(
        "g",
        { style: style },
        this.renderData()
      );
      return this.props.standalone ? _react2["default"].createElement(
        "svg",
        { style: style },
        group
      ) : group;
    }
  }], [{
    key: "role",
    value: "bar",
    enumerable: true
  }, {
    key: "propTypes",
    value: {
      /**
       * The animate prop specifies props for victory-animation to use. It this prop is
       * not given, the bar chart will not tween between changing data / style props.
       * Large datasets might animate slowly due to the inherent limits of svg rendering.
       * @examples {velocity: 0.02, onEnd: () => alert("done!")}
       */
      animate: _react.PropTypes.object,
      /**
       * The data prop specifies the data to be plotted. Data should be in the form of an array
       * of data points, or an array of arrays of data points for multiple datasets.
       * Each data point should be an object with x and y properties.
       * @examples [{x: 1, y:2}, {x: 2, y: 3}],
       * [[{x: "a", y: 1}, {x: "b", y: 2}], [{x: "a", y: 2}, {x: "b", y: 3}]]
       */
      data: _react.PropTypes.oneOfType([_react.PropTypes.arrayOf(_react.PropTypes.shape({
        x: _react.PropTypes.any,
        y: _react.PropTypes.any
      })), _react.PropTypes.arrayOf(_react.PropTypes.arrayOf(_react.PropTypes.shape({
        x: _react.PropTypes.any,
        y: _react.PropTypes.any
      })))]),
      /**
       * The dataAttributes prop describes how a data set should be styled.
       * This prop can be given as an object, or an array of objects. If this prop is
       * given as an array of objects, the properties of each object in the array will
       * be applied to the data points in the corresponding array of the data prop.
       * @examples {fill: "blue", opacity: 0.6}, [{fill: "red"}, {fill: "orange"}]
       */
      dataAttributes: _react.PropTypes.oneOfType([_react.PropTypes.object, _react.PropTypes.arrayOf(_react.PropTypes.object)]),
      /**
       * The categories prop specifies the categories for a bar chart. This prop should
       * be given as an array of string values, numeric values, or arrays. When this prop is
       * given as an array of arrays, the minimum and maximum values of the arrays define range bands,
       * allowing numeric data to be grouped into segments.
       * @examples ["dogs", "cats", "mice"], [[0, 5], [5, 10], [10, 15]]
       */
      categories: _victoryUtil2["default"].PropTypes.homogeneousArray,
      /**
       * The colorScale prop is an optional prop that defines the color scale the chart's bars
       * will be created on. This prop should be given as an array of CSS colors, or as a string
       * corresponding to one of the built in color scales. VictoryBar will automatically assign
       * values from this color scale to the bars unless colors are explicitly provided in the
       * `dataAttributes` prop.
       */
      colorScale: _react.PropTypes.oneOfType([_react.PropTypes.arrayOf(_react.PropTypes.string), _react.PropTypes.oneOf(["greyscale", "qualitative", "heatmap", "warm", "cool", "red", "green", "blue"])]),
      /**
       * The domain prop describes the range of values your bar chart will cover. This prop can be
       * given as a array of the minimum and maximum expected values for your bar chart,
       * or as an object that specifies separate arrays for x and y.
       * If this prop is not provided, a domain will be calculated from data, or other
       * available information.
       * @examples [-1, 1], {x: [0, 100], y: [0, 1]}
       */
      domain: _react.PropTypes.oneOfType([_victoryUtil2["default"].PropTypes.domain, _react.PropTypes.shape({
        x: _victoryUtil2["default"].PropTypes.domain,
        y: _victoryUtil2["default"].PropTypes.domain
      })]),
      /**
       * The domainPadding prop specifies a number of pixels of padding to add to the
       * beginning and end of a domain. This prop is useful for preventing 0 pixel bars,
       * and taking bar width into account.
       */
      domainPadding: _react.PropTypes.oneOfType([_react2["default"].PropTypes.shape({
        x: _victoryUtil2["default"].PropTypes.nonNegative,
        y: _victoryUtil2["default"].PropTypes.nonNegative
      }), _victoryUtil2["default"].PropTypes.nonNegative]),
      /**
       * The height props specifies the height of the chart container element in pixels
       */
      height: _victoryUtil2["default"].PropTypes.nonNegative,
      /**
       * The horizontal prop determines whether the bars will be laid vertically or
       * horizontally. The bars will be vertical if this prop is false or unspecified,
       * or horizontal if the prop is set to true.
       */
      horizontal: _react.PropTypes.bool,
      /**
       * The labels prop defines labels that will appear above each bar or
       * group of bars in your bar chart. This prop should be given as an array of values.
       * The number of elements in the label array should be equal to number of elements in
       * the categories array, or if categories is not defined, to the number of unique
       * x values in your data. Use this prop to add labels to individual bars, stacked bars,
       * and groups of bars.
       * @examples: ["spring", "summer", "fall", "winter"]
       */
      labels: _react.PropTypes.array,
      /**
       * The labelComponents prop takes in an array of entire, HTML-complete label components
       * which will be used to create labels for individual bars, stacked bars, or groups of
       * bars as appropriate.
       */
      labelComponents: _react.PropTypes.array,
      /**
       * The padding props specifies the amount of padding in number of pixels between
       * the edge of the chart and any rendered child components. This prop can be given
       * as a number or as an object with padding specified for top, bottom, left
       * and right.
       */
      padding: _react.PropTypes.oneOfType([_react.PropTypes.number, _react.PropTypes.shape({
        top: _react.PropTypes.number,
        bottom: _react.PropTypes.number,
        left: _react.PropTypes.number,
        right: _react.PropTypes.number
      })]),
      /**
       * The scale prop determines which scales your chart should use. This prop can be
       * given as a function, or as an object that specifies separate functions for x and y.
       * @examples d3Scale.time(), {x: d3Scale.linear(), y: d3Scale.log()}
       */
      scale: _react.PropTypes.oneOfType([_victoryUtil2["default"].PropTypes.scale, _react.PropTypes.shape({
        x: _victoryUtil2["default"].PropTypes.scale,
        y: _victoryUtil2["default"].PropTypes.scale
      })]),
      /**
       * The stacked prop determines whether the chart should consist of stacked bars.
       * When this prop is set to false, grouped bars will be rendered instead.
       */
      stacked: _react.PropTypes.bool,
      /**
       * The standalone prop determines whether the component will render a standalone svg
       * or a <g> tag that will be included in an external svg. Set standalone to false to
       * compose VictoryBar with other components within an enclosing <svg> tag.
       */
      standalone: _react.PropTypes.bool,
      /**
       * The style prop specifies styles for your chart. VictoryBar relies on Radium,
       * so valid Radium style objects should work for this prop, however height, width, and margin
       * are used to calculate range, and need to be expressed as a number of pixels
       * @examples {data: {fill: "red", width: 8}, labels: {fontSize: 12}}
       */
      style: _react.PropTypes.shape({
        parent: _react.PropTypes.object,
        data: _react.PropTypes.object,
        labels: _react.PropTypes.object
      }),
      /**
       * The width props specifies the width of the chart container element in pixels
       */
      width: _victoryUtil2["default"].PropTypes.nonNegative
    },
    enumerable: true
  }, {
    key: "defaultProps",
    value: {
      data: defaultData,
      domainPadding: 1,
      colorScale: "greyscale",
      height: 300,
      padding: 50,
      scale: _d3Scale2["default"].linear(),
      stacked: false,
      standalone: true,
      width: 450
    },
    enumerable: true
  }]);

  var _VictoryBar = VictoryBar;
  VictoryBar = (0, _radium2["default"])(VictoryBar) || VictoryBar;
  return VictoryBar;
})(_react2["default"].Component);

exports["default"] = VictoryBar;
module.exports = exports["default"];