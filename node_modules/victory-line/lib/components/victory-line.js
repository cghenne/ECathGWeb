"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _radium = require("radium");

var _radium2 = _interopRequireDefault(_radium);

var _d3Scale = require("d3-scale");

var _d3Scale2 = _interopRequireDefault(_d3Scale);

var _lineSegment = require("./line-segment");

var _lineSegment2 = _interopRequireDefault(_lineSegment);

var _lineLabel = require("./line-label");

var _lineLabel2 = _interopRequireDefault(_lineLabel);

var _victoryUtil = require("victory-util");

var _victoryUtil2 = _interopRequireDefault(_victoryUtil);

var _victoryAnimation = require("victory-animation");

var defaultStyles = {
  data: {
    strokeWidth: 2,
    fill: "none",
    stroke: "#756f6a",
    opacity: 1
  },
  labels: {
    padding: 5,
    fontFamily: "Helvetica",
    fontSize: 10,
    strokeWidth: 0,
    stroke: "transparent",
    textAnchor: "start"
  }
};

var VictoryLine = (function (_React$Component) {
  _inherits(VictoryLine, _React$Component);

  function VictoryLine() {
    _classCallCheck(this, _VictoryLine);

    _get(Object.getPrototypeOf(_VictoryLine.prototype), "constructor", this).apply(this, arguments);
  }

  _createClass(VictoryLine, [{
    key: "getCalculatedValues",
    value: function getCalculatedValues(props) {
      this.style = this.getStyles(props);
      this.padding = this.getPadding(props);
      this.range = {
        x: this.getRange(props, "x"),
        y: this.getRange(props, "y")
      };
      this.dataset = this.getData(props);
      this.dataSegments = this.getDataSegments();
      this.domain = {
        x: this.getDomain(props, "x"),
        y: this.getDomain(props, "y")
      };
      this.scale = {
        x: this.getScale(props, "x"),
        y: this.getScale(props, "y")
      };
    }
  }, {
    key: "getStyles",
    value: function getStyles(props) {
      var style = props.style || defaultStyles;
      var data = style.data;
      var labels = style.labels;
      var parent = style.parent;

      return {
        parent: _lodash2["default"].merge({ height: props.height, width: props.width }, parent),
        labels: _lodash2["default"].merge({}, defaultStyles.labels, labels),
        data: _lodash2["default"].merge({}, defaultStyles.data, data)
      };
    }
  }, {
    key: "getPadding",
    value: function getPadding(props) {
      var padding = _lodash2["default"].isNumber(props.padding) ? props.padding : 0;
      var paddingObj = _lodash2["default"].isObject(props.padding) ? props.padding : {};
      return {
        top: paddingObj.top || padding,
        bottom: paddingObj.bottom || padding,
        left: paddingObj.left || padding,
        right: paddingObj.right || padding
      };
    }
  }, {
    key: "getScale",
    value: function getScale(props, axis) {
      var scale = undefined;
      if (props.scale && props.scale[axis]) {
        scale = props.scale[axis].copy();
      } else if (props.scale && !_lodash2["default"].isObject(props.scale)) {
        scale = props.scale.copy();
      } else {
        scale = _d3Scale2["default"].linear().copy();
      }
      var range = this.range[axis];
      var domain = this.domain[axis];
      scale.range(range);
      scale.domain(domain);
      return scale;
    }
  }, {
    key: "getDomain",
    value: function getDomain(props, axis) {
      if (props.domain && props.domain[axis]) {
        return props.domain[axis];
      } else if (props.domain && !_lodash2["default"].isObject(props.domain)) {
        return props.domain;
      } else {
        return [_lodash2["default"].min(_lodash2["default"].pluck(this.dataset, axis)), _lodash2["default"].max(_lodash2["default"].pluck(this.dataset, axis))];
      }
    }
  }, {
    key: "getRange",
    value: function getRange(props, axis) {
      // if the range is not given in props, calculate it from width, height and margin
      return axis === "x" ? [this.padding.left, props.width - this.padding.right] : [props.height - this.padding.bottom, this.padding.top];
    }
  }, {
    key: "getData",
    value: function getData(props) {
      if (props.data) {
        return props.data;
      }
      var x = this.returnOrGenerateX(props);
      var y = this.returnOrGenerateY(props, x);
      var n = _lodash2["default"].min([x.length, y.length]);
      // create a dataset from x and y with n points
      var dataset = _lodash2["default"].zip(_lodash2["default"].take(x, n), _lodash2["default"].take(y, n));
      // return data as an array of objects
      return _lodash2["default"].map(dataset, function (point) {
        return { x: point[0], y: point[1] };
      });
    }
  }, {
    key: "returnOrGenerateX",
    value: function returnOrGenerateX(props) {
      if (props.x) {
        return props.x;
      }
      // if x is not given in props, create an array of values evenly
      // spaced across the x domain
      var domainFromProps = props.domain && props.domain.x || props.domain;
      var domainFromScale = props.scale && props.scale.x ? props.scale.x.domain() : props.scale.domain();
      var domain = domainFromProps || domainFromScale;
      var samples = _lodash2["default"].isArray(props.y) ? props.y.length : props.samples;
      var step = _lodash2["default"].max(domain) / samples;
      // return an array of x values spaced across the domain,
      // include the maximum of the domain
      var xArray = _lodash2["default"].union(_lodash2["default"].range(_lodash2["default"].min(domain), _lodash2["default"].max(domain), step), [_lodash2["default"].max(domain)]);
      return _lodash2["default"].filter(xArray, function (x) {
        return x !== 0;
      });
    }
  }, {
    key: "returnOrGenerateY",
    value: function returnOrGenerateY(props, x) {
      if (_lodash2["default"].isFunction(props.y)) {
        // if y is a function, apply the function y to to each value of the array x,
        // and return the results as an array
        return _lodash2["default"].map(x, function (datum) {
          return props.y(datum);
        });
      }
      // y is either a function or an array, and is never undefined
      // if it isn't a function, just return it.
      return props.y;
    }
  }, {
    key: "getDataSegments",
    value: function getDataSegments() {
      var orderedData = _lodash2["default"].sortBy(this.dataset, "x");
      var segments = [];
      var segmentStartIndex = 0;
      _lodash2["default"].each(orderedData, function (datum, index) {
        if (_lodash2["default"].isNull(datum.y) || _lodash2["default"].isUndefined(datum.y)) {
          segments.push(orderedData.slice(segmentStartIndex, index));
          segmentStartIndex = index + 1;
        }
      });
      segments.push(orderedData.slice(segmentStartIndex, orderedData.length));
      return _lodash2["default"].filter(segments, function (segment) {
        return !_lodash2["default"].isEmpty(segment);
      });
    }
  }, {
    key: "getLabelStyle",
    value: function getLabelStyle() {
      // match labels styles to data style by default (fill, opacity, others?)
      var opacity = this.style.data.opacity;
      // match label color to data color if it is not given.
      // use fill instead of stroke for text
      var fill = this.style.data.stroke;
      var padding = this.style.labels.padding || 0;
      return _lodash2["default"].merge({ opacity: opacity, fill: fill, padding: padding }, this.style.labels);
    }
  }, {
    key: "renderLine",
    value: function renderLine() {
      var _this = this;

      return _lodash2["default"].map(this.dataSegments, function (segment, index) {
        return _react2["default"].createElement(_lineSegment2["default"], {
          key: "line-segment-" + index,
          data: segment,
          interpolation: _this.props.interpolation,
          scale: _this.scale,
          style: _this.style.data
        });
      });
    }
  }, {
    key: "renderLabel",
    value: function renderLabel() {
      if (!this.props.label) {
        return undefined;
      }
      var position = {
        x: this.scale.x.call(this, _lodash2["default"].last(_lodash2["default"].flatten(this.dataSegments)).x),
        y: this.scale.y.call(this, _lodash2["default"].last(_lodash2["default"].flatten(this.dataSegments)).y)
      };
      return _react2["default"].createElement(_lineLabel2["default"], {
        key: "line-label",
        data: this.dataset,
        position: position,
        label: this.props.label,
        style: this.getLabelStyle()
      });
    }
  }, {
    key: "renderData",
    value: function renderData() {
      return _react2["default"].createElement(
        "g",
        { style: this.style.parent },
        this.renderLine(),
        this.renderLabel()
      );
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      // If animating, return a `VictoryAnimation` element that will create
      // a new `VictoryLine` with nearly identical props, except (1) tweened
      // and (2) `animate` set to null so we don't recurse forever.
      if (this.props.animate) {
        // Do less work by having `VictoryAnimation` tween only values that
        // make sense to tween. In the future, allow customization of animated
        // prop whitelist/blacklist?
        var animateData = _lodash2["default"].pick(this.props, ["data", "domain", "height", "padding", "samples", "style", "width", "x", "y"]);
        return _react2["default"].createElement(
          _victoryAnimation.VictoryAnimation,
          _extends({}, this.props.animate, { data: animateData }),
          function (props) {
            return _react2["default"].createElement(VictoryLine, _extends({}, _this2.props, props, { animate: null }));
          }
        );
      } else {
        this.getCalculatedValues(this.props);
      }
      var style = this.style.parent;
      var group = _react2["default"].createElement(
        "g",
        { style: style },
        this.renderData()
      );
      return this.props.standalone ? _react2["default"].createElement(
        "svg",
        { style: style },
        group
      ) : group;
    }
  }], [{
    key: "role",
    value: "line",
    enumerable: true
  }, {
    key: "propTypes",
    value: {
      /**
       * The animate prop specifies props for victory-animation to use. It this prop is
       * not given, the line will not tween between changing data / style props.
       * Large datasets might animate slowly due to the inherent limits of svg rendering.
       * @examples {velocity: 0.02, onEnd: () => alert("done!")}
       */
      animate: _react.PropTypes.object,
      /**
       * The data prop specifies the data to be plotted. Data should be in the form of an array
       * of data points where each data point should be an object with x and y properties.
       * @examples [{x: 1, y: 12}, {x: 10, y: 25}, {x: 100, y: 34}]
       */
      data: _react.PropTypes.arrayOf(_react.PropTypes.shape({
        x: _react.PropTypes.any,
        y: _react.PropTypes.any
      })),
      /**
       * The domain prop describes the range of values your chart will include. This prop can be
       * given as a array of the minimum and maximum expected values for your chart,
       * or as an object that specifies separate arrays for x and y.
       * If this prop is not provided, a domain will be calculated from data, or other
       * available information.
       * @examples [-1, 1], {x: [0, 100], y: [0, 1]}
       */
      domain: _react.PropTypes.oneOfType([_victoryUtil2["default"].PropTypes.domain, _react.PropTypes.shape({
        x: _victoryUtil2["default"].PropTypes.domain,
        y: _victoryUtil2["default"].PropTypes.domain
      })]),
      /**
       * The height props specifies the height of the chart container element in pixels
       */
      height: _victoryUtil2["default"].PropTypes.nonNegative,
      /**
       * The interpolation prop determines how data points should be connected
       * when plotting a line
       */
      interpolation: _react.PropTypes.oneOf(["basis", "basisClosed", "basisOpen", "bundle", "cardinal", "cardinalClosed", "cardinalOpen", "catmullRom", "catmullRomClosed", "catmullRomOpen", "linear", "linearClosed", "monotone", "natural", "radial", "step", "stepAfter", "stepBefore"]),
      /**
       * The label prop specifies a label to display at the end of a line component,
       * this prop can be given as a value, or as an entire label component
       */
      label: _react.PropTypes.any,
      /**
       * The padding props specifies the amount of padding in number of pixels between
       * the edge of the chart and any rendered child components. This prop can be given
       * as a number or as an object with padding specified for top, bottom, left
       * and right.
       */
      padding: _react.PropTypes.oneOfType([_react.PropTypes.number, _react.PropTypes.shape({
        top: _react.PropTypes.number,
        bottom: _react.PropTypes.number,
        left: _react.PropTypes.number,
        right: _react.PropTypes.number
      })]),
      /**
       * The samples prop specifies how many individual points to plot when plotting
       * y as a function of x. Samples is ignored if x props are provided instead.
       */
      samples: _victoryUtil2["default"].PropTypes.nonNegative,
      /**
       * The scale prop determines which scales your chart should use. This prop can be
       * given as a function, or as an object that specifies separate functions for x and y.
       * @examples d3Scale.time(), {x: d3Scale.linear(), y: d3Scale.log()}
       */
      scale: _react.PropTypes.oneOfType([_victoryUtil2["default"].PropTypes.scale, _react.PropTypes.shape({
        x: _victoryUtil2["default"].PropTypes.scale,
        y: _victoryUtil2["default"].PropTypes.scale
      })]),
      /**
       * The standalone prop determines whether the component will render a standalone svg
       * or a <g> tag that will be included in an external svg. Set standalone to false to
       * compose VictoryLine with other components within an enclosing <svg> tag.
       */
      standalone: _react.PropTypes.bool,
      /**
       * The style prop specifies styles for your chart. VictoryLine relies on Radium,
       * so valid Radium style objects should work for this prop, however height, width, and margin
       * are used to calculate range, and need to be expressed as a number of pixels
       * @examples {data: {stroke: "red"}, labels: {fontSize: 14}}
       */
      style: _react.PropTypes.shape({
        parent: _react.PropTypes.object,
        data: _react.PropTypes.object,
        labels: _react.PropTypes.object
      }),
      /**
       * The width props specifies the width of the chart container element in pixels
       */
      width: _victoryUtil2["default"].PropTypes.nonNegative,
      /**
       * The x prop provides another way to supply data for line to plot. This prop can be given
       * as an array of values, and it will be plotted against whatever y prop is provided. If no
       * props are provided for y, the values in x will be plotted as the identity function (x) => x.
       * @examples [1, 2, 3]
       */
      x: _victoryUtil2["default"].PropTypes.homogeneousArray,
      /**
       * The y prop provides another way to supply data for line to plot. This prop can be given
       * as a function of x, or an array of values. If x props are given, they will be used
       * in plotting (x, y) data points. If x props are not provided, a set of x values
       * evenly spaced across the x domain will be calculated, and used for plotting data points.
       * @examples (x) => Math.sin(x), [1, 2, 3]
       */
      y: _react.PropTypes.oneOfType([_react.PropTypes.array, _react.PropTypes.func])
    },
    enumerable: true
  }, {
    key: "defaultProps",
    value: {
      height: 300,
      interpolation: "linear",
      padding: 50,
      samples: 50,
      scale: _d3Scale2["default"].linear(),
      standalone: true,
      width: 450,
      y: function y(x) {
        return x;
      }
    },
    enumerable: true
  }]);

  var _VictoryLine = VictoryLine;
  VictoryLine = (0, _radium2["default"])(VictoryLine) || VictoryLine;
  return VictoryLine;
})(_react2["default"].Component);

exports["default"] = VictoryLine;
module.exports = exports["default"];