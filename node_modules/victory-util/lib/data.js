"use strict";

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

var _lodashArrayCompact = require("lodash/array/compact");

var _lodashArrayCompact2 = _interopRequireDefault(_lodashArrayCompact);

var _lodashArrayFindIndex = require("lodash/array/findIndex");

var _lodashArrayFindIndex2 = _interopRequireDefault(_lodashArrayFindIndex);

var _lodashArrayFlatten = require("lodash/array/flatten");

var _lodashArrayFlatten2 = _interopRequireDefault(_lodashArrayFlatten);

var _lodashArrayTake = require("lodash/array/take");

var _lodashArrayTake2 = _interopRequireDefault(_lodashArrayTake);

var _lodashArrayUnion = require("lodash/array/union");

var _lodashArrayUnion2 = _interopRequireDefault(_lodashArrayUnion);

var _lodashLangIsEmpty = require("lodash/lang/isEmpty");

var _lodashLangIsEmpty2 = _interopRequireDefault(_lodashLangIsEmpty);

var _lodashObjectMerge = require("lodash/object/merge");

var _lodashObjectMerge2 = _interopRequireDefault(_lodashObjectMerge);

var _lodashUtilityRange = require("lodash/utility/range");

var _lodashUtilityRange2 = _interopRequireDefault(_lodashUtilityRange);

var _lodashArrayUniq = require("lodash/array/uniq");

var _lodashArrayUniq2 = _interopRequireDefault(_lodashArrayUniq);

var _lodashArrayZipObject = require("lodash/array/zipObject");

var _lodashArrayZipObject2 = _interopRequireDefault(_lodashArrayZipObject);

var _lodashArrayZip = require("lodash/array/zip");

var _lodashArrayZip2 = _interopRequireDefault(_lodashArrayZip);

var _collection = require("./collection");

var Collection = _interopRequireWildcard(_collection);

var _style = require("./style");

var Style = _interopRequireWildcard(_style);

var _scale = require("./scale");

var _scale2 = _interopRequireDefault(_scale);

module.exports = {
  // String Data
  createStringMap: function createStringMap(props, axis) {
    var stringsFromAxes = this.getStringsFromAxes(props, axis);
    var stringsFromCategories = this.getStringsFromCategories(props, axis);
    var stringsFromData = this.getDataStrings(props, axis);
    var allStrings = (0, _lodashArrayUniq2["default"])((0, _lodashArrayCompact2["default"])([].concat(_toConsumableArray(stringsFromAxes), _toConsumableArray(stringsFromCategories), _toConsumableArray(stringsFromData))));
    return (0, _lodashLangIsEmpty2["default"])(allStrings) ? null : (0, _lodashArrayZipObject2["default"])(allStrings.map(function (string, index) {
      return [string, index + 1];
    }));
  },

  getStringsFromAxes: function getStringsFromAxes(props, axis) {

    if (!props.tickValues || !Array.isArray(props.tickValues) && !props.tickValues[axis]) {
      return [];
    }
    var tickValueArray = props.tickValues[axis] || props.tickValues;
    return tickValueArray.filter(function (val) {
      return typeof val === "string";
    });
  },

  getStringsFromCategories: function getStringsFromCategories(props, axis) {
    // TODO generalize for independent vertical axes
    if (!props.categories || axis !== "x") {
      return [];
    } else {
      var categoryArray = (0, _lodashArrayCompact2["default"])((0, _lodashArrayFlatten2["default"])(props.categories));
      return categoryArray.filter(function (val) {
        return typeof val === "string";
      });
    }
  },

  getDataStrings: function getDataStrings(props, axis) {
    var xyStrings = this.getStringsFromXY(props, axis);
    var dataStrings = this.getStringsFromData(props, axis);
    var allStrings = (0, _lodashArrayFlatten2["default"])([].concat(_toConsumableArray(dataStrings), _toConsumableArray(xyStrings)));
    // return a unique set of strings
    return (0, _lodashArrayCompact2["default"])((0, _lodashArrayUniq2["default"])(allStrings));
  },

  getStringsFromData: function getStringsFromData(props, axis) {
    if (!props.data) {
      return [];
    }
    var axisData = (0, _lodashArrayFlatten2["default"])(props.data).map(function (datum) {
      return datum && datum[axis];
    });
    return axisData.filter(function (datum) {
      return typeof datum === "string";
    });
  },

  getStringsFromXY: function getStringsFromXY(props, axis) {
    if (!props[axis] || !Array.isArray(props[axis])) {
      return [];
    }
    var allData = (0, _lodashArrayFlatten2["default"])(props[axis]);
    return allData.filter(function (element) {
      return typeof element === "string";
    });
  },

  // For components that take multiple datasets
  consolidateData: function consolidateData(props) {
    var datasets = Array.isArray(props.data[0]) ? props.data : [props.data];
    return this.formatData(datasets, props);
  },

  // for components that take single datasets
  getData: function getData(props) {
    if (props.data) {
      return this.formatData(props.data, props);
    }
    var x = this.returnOrGenerateX(props);
    var y = this.returnOrGenerateY(props, x);
    var n = Math.min(x.length, y.length);
    // create a dataset from x and y with n points
    var dataset = (0, _lodashArrayZip2["default"])((0, _lodashArrayTake2["default"])(x, n), (0, _lodashArrayTake2["default"])(y, n));
    // return data as an array of objects
    var data = dataset.map(function (point) {
      return { x: point[0], y: point[1] };
    });
    return this.formatData(data, props);
  },

  returnOrGenerateX: function returnOrGenerateX(props) {
    if (props.x) {
      return props.x;
    }
    // if x is not given in props, create an array of values evenly
    // spaced across the x domain
    var domain = props.domain ? props.domain.x || props.domain : _scale2["default"].getBaseScale(props, "x").domain();
    var samples = Array.isArray(props.y) ? props.y.length : props.samples;
    var step = Math.max.apply(Math, _toConsumableArray(domain)) / samples;
    // return an array of x values spaced across the domain,
    // include the maximum of the domain
    return (0, _lodashArrayUnion2["default"])((0, _lodashUtilityRange2["default"])(Math.min.apply(Math, _toConsumableArray(domain)), Math.max.apply(Math, _toConsumableArray(domain)), step), [Math.max.apply(Math, _toConsumableArray(domain))]);
  },

  returnOrGenerateY: function returnOrGenerateY(props, x) {
    if (props.y && typeof props.y === "function") {
      // if y is a function, apply the function y to to each value of the array x,
      // and return the results as an array
      return x.map(function (datum) {
        return props.y(datum);
      });
    }
    // y is either a function or an array, and is never undefined
    // if it isn't a function, just return it.
    return props.y;
  },

  formatData: function formatData(allData, props) {
    var _this = this;

    if (!allData) {
      return [];
    }
    var stringMap = {
      x: this.createStringMap(props, "x"),
      y: this.createStringMap(props, "y")
    };
    var _formatData = function _formatData(dataset) {
      var cleanedData = _this.cleanData(dataset, props);
      return cleanedData.map(function (data) {
        return (0, _lodashObjectMerge2["default"])({}, data, {
          category: _this.determineCategoryIndex(data.x, props.categories),
          // map string data to numeric values, and add names
          x: typeof data.x === "string" ? stringMap.x[data.x] : data.x,
          xName: typeof data.x === "string" ? data.x : undefined,
          y: typeof data.y === "string" ? stringMap.y[data.y] : data.y,
          yName: typeof data.y === "string" ? data.y : undefined
        });
      });
    };
    if (Collection.isArrayOfArrays(allData)) {
      return allData.map(function (dataset, index) {
        return {
          attrs: _this.getAttributes(props, index),
          data: _formatData(dataset)
        };
      });
    }
    return _formatData(allData);
  },

  cleanData: function cleanData(dataset, props) {
    // Some scale types break when certain data is supplies. This method will
    // remove data points that break scales. So far this method only removes
    // zeroes for log scales
    // TODO other cases?
    var scaleType = {
      x: _scale2["default"].getScaleType(props, "x"),
      y: _scale2["default"].getScaleType(props, "y")
    };
    if (scaleType.x !== "log" && scaleType.y !== "log") {
      return dataset;
    }
    var rules = function rules(datum, axis) {
      return scaleType[axis] === "log" ? datum[axis] !== 0 : true;
    };
    return dataset.filter(function (datum) {
      return rules(datum, "x") && rules(datum, "y");
    });
  },

  determineCategoryIndex: function determineCategoryIndex(x, categories) {
    // if categories don't exist or are not given as an array of arrays, return undefined;
    if (!categories || !Array.isArray(categories[0])) {
      return undefined;
    }
    // determine which range band this x value belongs to, and return the index of that range band.
    return (0, _lodashArrayFindIndex2["default"])(categories, function (category) {
      return x >= Math.min.apply(Math, _toConsumableArray(category)) && x <= Math.max.apply(Math, _toConsumableArray(category));
    });
  },

  getAttributes: function getAttributes(props, index) {
    var attributes = props.dataAttributes && props.dataAttributes[index] ? props.dataAttributes[index] : props.dataAttributes;
    if (attributes) {
      attributes.fill = attributes.fill || this.getColor(props, index);
    } else {
      attributes = { fill: this.getColor(props, index) };
    }
    var requiredAttributes = {
      name: attributes && attributes.name ? attributes.name : "data-" + index
    };
    return (0, _lodashObjectMerge2["default"])(requiredAttributes, attributes);
  },

  getColor: function getColor(props, index) {
    // check for styles first
    if (props.style && props.style.data && props.style.data.fill) {
      return props.style.data.fill;
    }
    var colorScale = Array.isArray(props.colorScale) ? props.colorScale : Style.getColorScale(props.colorScale);
    return colorScale[index % colorScale.length];
  }
};