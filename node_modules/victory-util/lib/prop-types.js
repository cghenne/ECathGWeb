"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _lodashFunctionBind = require("lodash/function/bind");

var _lodashFunctionBind2 = _interopRequireDefault(_lodashFunctionBind);

var _react = require("react");

var _type = require("./type");

var _scale = require("./scale");

var Scale = _interopRequireWildcard(_scale);

/**
 * Return a new validator based on `validator` but with the option to chain
 * `isRequired` onto the validation. This is nearly identical to how React
 * does it internally, but they don't expose their helper for us to use.
 * @param {Function} validator Validation function.
 * @returns {Function} Validator with `isRequired` option.
 */
var makeChainable = function makeChainable(validator) {
  /* eslint-disable max-params */
  var _chainable = function _chainable(isRequired, props, propName, componentName) {
    var value = props[propName];
    if (typeof value === "undefined" || value === null) {
      if (isRequired) {
        return new Error("Required `" + propName + "` was not specified in `" + componentName + "`.");
      }
      return null;
    }
    return validator(props, propName, componentName);
  };
  var chainable = (0, _lodashFunctionBind2["default"])(_chainable, null, false);
  chainable.isRequired = (0, _lodashFunctionBind2["default"])(_chainable, null, true);
  return chainable;
};

exports.makeChainable = makeChainable;
/**
 * Check that the value is a non-negative number.
 */
var nonNegative = makeChainable(function (props, propName, componentName) {
  var error = _react.PropTypes.number(props, propName, componentName);
  if (error) {
    return error;
  }
  var value = props[propName];
  if (value < 0) {
    return new Error("`" + propName + "` in `" + componentName + "` must be non-negative.");
  }
});

exports.nonNegative = nonNegative;
/**
 * Check that the value is an Array of two unique values.
 */
var domain = makeChainable(function (props, propName, componentName) {
  var error = _react.PropTypes.array(props, propName, componentName);
  if (error) {
    return error;
  }
  var value = props[propName];
  if (value.length !== 2 || value[1] === value[0]) {
    return new Error("`" + propName + "` in `" + componentName + "` must be an array of two unique numeric values.");
  }
});

exports.domain = domain;
/**
 * Check that the value looks like a d3 `scale` function.
 */
var scale = makeChainable(function (props, propName, componentName) {
  var value = props[propName];
  if (!Scale.validScale(value)) {
    return new Error("`" + propName + "` in `" + componentName + "` must be a d3 scale.");
  }
});

exports.scale = scale;
/**
 * Check that an array contains items of the same type.
 */
var homogeneousArray = makeChainable(function (props, propName, componentName) {
  var error = _react.PropTypes.array(props, propName, componentName);
  if (error) {
    return error;
  }
  var value = props[propName];
  if (value.length > 1) {
    var _constructor = (0, _type.getConstructor)(value[0]);
    for (var i = 1; i < value.length; i++) {
      var otherConstructor = (0, _type.getConstructor)(value[i]);
      if (_constructor !== otherConstructor) {
        var constructorName = (0, _type.getConstructorName)(value[0]);
        var otherConstructorName = (0, _type.getConstructorName)(value[i]);
        return new Error("Expected `" + propName + "` in `" + componentName + "` to be a " + ("homogeneous array, but found types `" + constructorName + "` and ") + ("`" + otherConstructorName + "`."));
      }
    }
  }
});
exports.homogeneousArray = homogeneousArray;