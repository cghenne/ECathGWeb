"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _radium = require("radium");

var _radium2 = _interopRequireDefault(_radium);

var _victoryUtil = require("victory-util");

var _victoryAxis = require("victory-axis");

var _victoryLine = require("victory-line");

var defaultAxes = {
  independent: _react2["default"].createElement(_victoryAxis.VictoryAxis, { animate: { velocity: 0.02 } }),
  dependent: _react2["default"].createElement(_victoryAxis.VictoryAxis, { dependentAxis: true, animate: { velocity: 0.02 } })
};

var defaultData = _react2["default"].createElement(_victoryLine.VictoryLine, { domain: { x: [0, 1], y: [0, 1] } });

var VictoryChart = (function (_React$Component) {
  _inherits(VictoryChart, _React$Component);

  function VictoryChart() {
    _classCallCheck(this, _VictoryChart);

    _get(Object.getPrototypeOf(_VictoryChart.prototype), "constructor", this).apply(this, arguments);
  }

  _createClass(VictoryChart, [{
    key: "getComponents",
    value: function getComponents(props) {
      this.groupedDataTypes = ["bar"];
      this.childComponents = this.getChildComponents(props);
      this.dataComponents = this.getDataComponents();
      this.groupedDataComponents = this.getGroupedDataComponents();
      this.axisComponents = this.getAxisComponents();
    }
  }, {
    key: "getCalculatedValues",
    value: function getCalculatedValues(props) {
      this.style = this.getStyles(props);
      this.padding = this.getPadding(props);
      this.range = {
        x: this.getRange(props, "x"),
        y: this.getRange(props, "y")
      };
      this.axisOrientations = this.getAxisOrientations();
      this.independentAxis = this.axisComponents.y.props.dependentAxis ? "x" : "y";
      this.dependentAxis = this.axisComponents.y.props.dependentAxis ? "y" : "x";
      this.stringMap = {
        x: this.createStringMap("x"),
        y: this.createStringMap("y")
      };
      this.domain = {};
      this.domain.x = this.getDomain(props, "x");
      this.domain.y = this.getDomain(props, "y");
      this.scale = {
        x: this.getScale(props, "x"),
        y: this.getScale(props, "y")
      };
      this.tickValues = {
        x: this.getTickValues("x"),
        y: this.getTickValues("y")
      };
      this.tickFormat = {
        x: this.getTickFormat("x"),
        y: this.getTickFormat("y")
      };
      this.axisOffset = this.getAxisOffset(props);
    }
  }, {
    key: "getStyles",
    value: function getStyles(props) {
      var styleProps = props.style && props.style.parent;
      return {
        parent: _lodash2["default"].merge({
          height: props.height,
          width: props.width
        }, styleProps) };
    }
  }, {
    key: "getPadding",
    value: function getPadding(props) {
      var padding = _lodash2["default"].isNumber(props.padding) ? props.padding : 0;
      var paddingObj = _lodash2["default"].isObject(props.padding) ? props.padding : {};
      return {
        top: paddingObj.top || padding,
        bottom: paddingObj.bottom || padding,
        left: paddingObj.left || padding,
        right: paddingObj.right || padding
      };
    }
  }, {
    key: "getRange",
    value: function getRange(props, axis) {
      return axis === "x" ? [this.padding.left, props.width - this.padding.right] : [props.height - this.padding.bottom, this.padding.top];
    }
  }, {
    key: "getAxisType",
    value: function getAxisType(child) {
      if (!child.type || child.type.role !== "axis") {
        return undefined;
      }
      return child.props.dependentAxis ? "dependent" : "independent";
    }
  }, {
    key: "getChildComponents",
    value: function getChildComponents(props) {
      var _this = this;

      // set up a counter for component types
      var count = (function () {
        var counts = {};
        return {
          add: function add(child) {
            var type = child.type && child.type.role;
            var axis = _this.getAxisType(child);
            if (!counts[type]) {
              counts[type] = axis ? { independent: 0, dependent: 0 } : 0;
            }
            if (axis) {
              counts[type][axis] = counts[type][axis] += 1;
            } else {
              counts[type] = counts[type] += 1;
            }
          },
          limitReached: function limitReached(child) {
            var type = child.type && child.type.role;
            var axis = _this.getAxisType(child);
            if (!counts[type]) {
              return false;
            } else if (axis) {
              return counts[type][axis] > 1;
            } else if (_lodash2["default"].includes(_this.groupedDataTypes, type)) {
              // TODO: should we remove the limit on grouped data types?
              return counts[type] > 1;
            }
            return false;
          },
          total: function total(type, axis) {
            var totalCount = axis && counts[type] ? counts[type][axis] : counts[type];
            return totalCount || 0;
          }
        };
      })();

      if (!props.children) {
        return [defaultData, defaultAxes.independent, defaultAxes.dependent];
      }
      var childComponents = [];
      // loop through children, and add each child to the childComponents array
      // unless the limit for that child type has already been reached.
      _react2["default"].Children.forEach(props.children, function (child) {
        if (!child || !child.type) {
          return;
        }
        var type = child.type && child.type.role;
        if (count.limitReached(child)) {
          var msg = type === "axis" ? "Only one VictoryAxis component of each axis type is allowed when using the " + "VictoryChart wrapper. Only the first axis will be used. Please compose " + "multi-axis charts manually" : "Only one \" + type + \"component is allowed per chart. If you are trying " + "to plot several datasets, please pass an array of data arrays directly " + ("into " + type + ".");
          _victoryUtil.Log.warn(msg);
        }
        childComponents.push(child);
        count.add(child);
      });

      // Add default axis components if necessary
      // TODO: should we add both axes by default?
      if (count.total("axis", "independent") < 1) {
        childComponents.push(defaultAxes.independent);
      }
      if (count.total("axis", "dependent") < 1) {
        childComponents.push(defaultAxes.dependent);
      }

      // Add defaut data if no data is provided
      var dataComponents = _lodash2["default"].filter(childComponents, function (child) {
        var type = child.type && child.type.role;
        return type !== "axis";
      });

      if (dataComponents.length === 0) {
        childComponents.push(defaultData);
      }
      return childComponents;
    }
  }, {
    key: "getDataComponents",
    value: function getDataComponents() {
      var _this2 = this;

      return _lodash2["default"].filter(this.childComponents, function (child) {
        var type = child.type && child.type.role;
        return !_lodash2["default"].includes(_this2.groupedDataTypes, type) && type !== "axis";
      });
    }
  }, {
    key: "getGroupedDataComponents",
    value: function getGroupedDataComponents() {
      var _this3 = this;

      return _lodash2["default"].filter(this.childComponents, function (child) {
        var type = child.type && child.type.role;
        return _lodash2["default"].includes(_this3.groupedDataTypes, type);
      });
    }
  }, {
    key: "getAxisComponents",
    value: function getAxisComponents() {
      var _this4 = this;

      // TODO: currently flipped axes are only supported for bar, a groupedDataComponent
      var flippedAxes = _lodash2["default"].some(this.groupedDataComponents, function (component) {
        return component.props.horizontal;
      });
      var typicalOrientations = {
        independent: ["top", "bottom"],
        dependent: ["left", "right"]
      };
      var typicalAxes = { independent: "x", dependent: "y" };
      var atypicalAxes = { independent: "y", dependent: "x" };
      var components = _lodash2["default"].filter(this.childComponents, function (child) {
        var type = child.type && child.type.role;
        return type === "axis";
      });
      var componentsWithType = _lodash2["default"].map(components, function (component) {
        return [_this4.getAxisType(component), component];
      });
      var axisComponents = _lodash2["default"].zipObject(componentsWithType);
      var componentsWithOrientation = _lodash2["default"].map(_lodash2["default"].keys(axisComponents), function (type) {
        var component = axisComponents[type];
        var orientation = component.props.orientation;
        if (!orientation) {
          return flippedAxes ? [atypicalAxes[type], component] : [typicalAxes[type], component];
        }
        return _lodash2["default"].includes(typicalOrientations, orientation) ? [atypicalAxes[type], component] : [typicalAxes[type], component];
      });
      return _lodash2["default"].merge({}, axisComponents, _lodash2["default"].zipObject(componentsWithOrientation));
    }
  }, {
    key: "getAxisOrientations",
    value: function getAxisOrientations() {
      var _this5 = this;

      var getDefaultOrientation = function getDefaultOrientation(type) {
        return type === "independent" || type === "x" ? "bottom" : "left";
      };

      var orientations = _lodash2["default"].map(_lodash2["default"].keys(this.axisComponents), function (type) {
        var component = _this5.axisComponents[type];
        var orientation = component.props.orientation || getDefaultOrientation(type);
        return [type, orientation];
      });
      return _lodash2["default"].zipObject(orientations);
    }
  }, {
    key: "createStringMap",
    value: function createStringMap(axis) {
      // if tick values exist and are strings, create a map using those strings
      // dont alter the order.
      var tickMap = this._getStringsFromAxes(axis);

      // if categories exist in grouped data, create a string map based on
      // categories which preserves order
      var categoryMap = this._getStringsFromCategories(axis);

      // collect all the strings from data and x / y props, and return a
      // unique sorted set of strings
      var dataStrings = this._getStringsFromData(axis);

      return _lodash2["default"].isEmpty(dataStrings) ? tickMap || categoryMap || null : _lodash2["default"].zipObject(_lodash2["default"].map(dataStrings, function (string, index) {
        var tickValue = tickMap && tickMap[string];
        var categoryValue = categoryMap && categoryMap[string];
        var value = tickValue || categoryValue || index + 1;
        return [string, value];
      }));
    }
  }, {
    key: "_getStringsFromAxes",
    value: function _getStringsFromAxes(axis) {
      var axisComponent = this.axisComponents[axis];
      var tickValues = axisComponent.props.tickValues ? axisComponent.props.tickValues[axis] || axisComponent.props.tickValues : undefined;
      return tickValues && _victoryUtil.Collection.containsStrings(tickValues) ? _lodash2["default"].zipObject(_lodash2["default"].map(tickValues, function (tick, index) {
        return ["" + tick, index + 1];
      })) : undefined;
    }
  }, {
    key: "_getStringsFromCategories",
    value: function _getStringsFromCategories(axis) {
      if (this.groupedDataComponents && axis === this.independentAxis) {
        var allCategories = _lodash2["default"].map(this.groupedDataComponents, function (component) {
          var categories = component.props.categories;
          return categories && _victoryUtil.Collection.containsStrings(categories) ? categories : undefined;
        });
        var stringCategories = _lodash2["default"].compact(_lodash2["default"].flatten(allCategories));
        return _lodash2["default"].isEmpty(stringCategories) ? undefined : _lodash2["default"].zipObject(_lodash2["default"].map(stringCategories, function (category, index) {
          return ["" + category, index + 1];
        }));
      }
    }
  }, {
    key: "_getStringsFromData",
    value: function _getStringsFromData(axis) {
      // Collect strings from dataComponents and groupedDataComponents props.data
      var allChildData = this.dataComponents.concat(this.groupedDataComponents);
      var allStrings = [];
      var allData = _lodash2["default"].map(allChildData, function (dataComponent) {
        return dataComponent.props.data;
      });

      // collect strings from allData
      if (allData) {
        var data = _lodash2["default"].flattenDeep(allData);
        var stringData = _lodash2["default"].chain(data).pluck(axis).map(function (datum) {
          return _lodash2["default"].isString(datum) ? datum : null;
        }).value();
        allStrings.push(stringData);
      }
      // collect strings from  data components props x or props y
      var allXYData = _lodash2["default"].map(allChildData, function (dataComponent) {
        return dataComponent.props[axis];
      });
      if (allXYData) {
        _lodash2["default"].each(_lodash2["default"].flattenDeep(allXYData), function (element) {
          if (_lodash2["default"].isString(element)) {
            allStrings.push(element);
          }
        });
      }
      // create a unique, sorted set of strings
      return _lodash2["default"].chain(allStrings).flatten().compact().uniq().sort().value();
    }
  }, {
    key: "formatChildData",
    value: function formatChildData(childData, categories) {
      var _this6 = this;

      var _formatData = function _formatData(dataset) {
        return _lodash2["default"].map(dataset, function (data) {
          return _lodash2["default"].merge({}, data, {
            category: _this6.determineCategoryIndex(data.x, categories),
            // map string data to numeric values, and add names
            x: _lodash2["default"].isString(data.x) ? _this6.stringMap.x[data.x] : data.x,
            xName: _lodash2["default"].isString(data.x) ? data.x : undefined,
            y: _lodash2["default"].isString(data.y) ? _this6.stringMap.y[data.y] : data.y,
            yName: _lodash2["default"].isString(data.y) ? data.y : undefined
          });
        });
      };
      if (_victoryUtil.Collection.isArrayOfArrays(childData)) {
        return _lodash2["default"].map(childData, function (dataset) {
          return _formatData(dataset);
        });
      }
      return _formatData(childData);
    }
  }, {
    key: "determineCategoryIndex",
    value: function determineCategoryIndex(x, categories) {
      // if categories don't exist or are not given as an array of arrays, return undefined;
      if (!categories || !_lodash2["default"].isArray(categories[0])) {
        return undefined;
      }
      // determine which range band this x value belongs to, and return the index of that range band.
      return categories.findIndex(function (category) {
        return x >= Math.min.apply(Math, _toConsumableArray(category)) && x <= Math.max.apply(Math, _toConsumableArray(category));
      });
    }
  }, {
    key: "getDomain",
    value: function getDomain(props, axis) {
      var _this7 = this;

      if (props.domain && (_lodash2["default"].isArray(props.domain) || props.domain[axis])) {
        var propsDomain = _lodash2["default"].isArray(props.domain) ? props.domain : props.domain[axis];
        var paddedPropsDomain = this.padDomain(propsDomain, axis);
        return this.orientDomain(paddedPropsDomain, axis);
      }
      var dataDomains = _lodash2["default"].map(this.dataComponents, function (component) {
        return _this7.getDomainFromData(component, axis);
      });
      var groupedDataDomains = _lodash2["default"].map(this.groupedDataComponents, function (component) {
        return _this7.getDomainFromGroupedData(component, axis);
      });
      var axisDomain = this.getDomainFromAxis(axis);
      var domainFromChildren = _victoryUtil.Collection.removeUndefined(_lodash2["default"].flattenDeep(dataDomains.concat(groupedDataDomains, axisDomain)));
      var domain = _lodash2["default"].isEmpty(domainFromChildren) ? [0, 1] : [_lodash2["default"].min(domainFromChildren), _lodash2["default"].max(domainFromChildren)];
      var paddedDomain = this.padDomain(domain, axis);
      return this.orientDomain(paddedDomain, axis);
    }
  }, {
    key: "orientDomain",
    value: function orientDomain(domain, axis) {
      // If the other axis is in a reversed orientation, the domain of this axis
      // needs to be reversed
      var otherAxis = axis === "x" ? "y" : "x";
      var orientation = this.axisOrientations[otherAxis];

      if (this.independentAxis === "x") {
        return orientation === "bottom" || orientation === "left" ? domain : domain.concat().reverse();
      } else {
        return orientation === "bottom" || orientation === "left" ? domain.concat().reverse() : domain;
      }
    }
  }, {
    key: "getDomainFromData",
    value: function getDomainFromData(component, axis) {
      // TODO refactor for code cleanliness
      var dataByAxis = undefined;
      if (component.props.domain) {
        return component.props.domain[axis] || component.props.domain;
      } else if (component.props.data) {
        var formattedData = this.formatChildData(component.props.data, component.props.categories);
        dataByAxis = _lodash2["default"].map(_lodash2["default"].flatten(formattedData), function (data) {
          return data[axis];
        });
      } else if (component.props[axis]) {
        dataByAxis = _lodash2["default"].isFunction(component.props[axis]) ? _lodash2["default"].pluck(this.generateData(component), axis) : component.props[axis];
      }
      return dataByAxis ? [_lodash2["default"].min(dataByAxis), _lodash2["default"].max(dataByAxis)] : undefined;
    }
  }, {
    key: "_isStackedComponentData",
    value: function _isStackedComponentData(component, axis) {
      // checks whether grouped data is stacked, and whether there are multiple
      // datasets to stack.
      return component.props.stacked === true && _victoryUtil.Collection.isArrayOfArrays(component.props.data) && axis === this.dependentAxis;
    }
  }, {
    key: "getDomainFromGroupedData",
    value: function getDomainFromGroupedData(component, axis) {
      if (component.props.domain) {
        return component.props.domain[axis] || component.props.domain;
      } else if (component.props.categories && axis === this.independentAxis) {
        return this.getDomainFromCategories(component, axis);
      }
      var datasets = this.formatChildData(component.props.data);
      // find the global min and max
      var axisData = _lodash2["default"].flatten(datasets).map(function (data) {
        return data[axis];
      });
      var globalMin = Math.min.apply(Math, _toConsumableArray(axisData));
      var globalMax = Math.max.apply(Math, _toConsumableArray(axisData));

      var cumulativeData = this._isStackedComponentData(component, axis) ? this.getCumulativeData(datasets, "y") : [];

      var cumulativeMaxArray = cumulativeData.map(function (dataset) {
        return dataset.reduce(function (memo, val) {
          return val > 0 ? memo + val : memo;
        }, 0);
      });

      var cumulativeMinArray = cumulativeData.map(function (dataset) {
        return dataset.reduce(function (memo, val) {
          return val < 0 ? memo + val : memo;
        }, 0);
      });

      var cumulativeMin = Math.min.apply(Math, _toConsumableArray(cumulativeMinArray));
      // use greatest min / max
      var domainMin = cumulativeMin < 0 ? cumulativeMin : globalMin;
      var domainMax = Math.max(globalMax, Math.max.apply(Math, _toConsumableArray(cumulativeMaxArray)));
      return [domainMin, domainMax];
    }
  }, {
    key: "getCumulativeData",
    value: function getCumulativeData(datasets, axis) {
      var categories = [];
      var xValues = [];
      datasets.forEach(function (dataset) {
        dataset.forEach(function (data) {
          if (data.category !== undefined && !_lodash2["default"].includes(categories, data.category)) {
            categories.push(data.category);
          } else if (!_lodash2["default"].includes(xValues, data.x)) {
            xValues.push(data.x);
          }
        });
      });

      var dataByCategory = function dataByCategory() {
        return categories.map(function (value) {
          var categoryData = datasets.filter(function (data) {
            return data.category === value;
          });
          return _lodash2["default"].flatten(categoryData.map(function (data) {
            return data[axis];
          }));
        });
      };

      var dataByIndex = function dataByIndex() {
        return xValues.map(function (value, index) {
          return datasets.map(function (data) {
            return data[index] && data[index][axis];
          });
        });
      };

      return _lodash2["default"].isEmpty(categories) ? dataByIndex() : dataByCategory();
    }
  }, {
    key: "getDomainFromCategories",
    value: function getDomainFromCategories(component, axis) {
      var _this8 = this;

      var categories = _lodash2["default"].flatten(component.props.categories);
      var categoryValues = _victoryUtil.Collection.containsStrings(categories) ? _lodash2["default"].map(categories, function (value) {
        return _this8.stringMap[axis][value];
      }) : categories;
      return [_lodash2["default"].min(categoryValues), _lodash2["default"].max(categoryValues)];
    }
  }, {
    key: "getDomainFromAxis",
    value: function getDomainFromAxis(axis) {
      var _this9 = this;

      var component = this.axisComponents[axis];
      if (component.props.domain) {
        return component.props.domain;
      }
      var ticks = component.props.tickValues;
      if (ticks) {
        var tickValues = _victoryUtil.Collection.containsStrings(ticks) ? _lodash2["default"].map(ticks, function (tick) {
          return _this9.stringMap[axis][tick];
        }) : ticks;
        return [_lodash2["default"].min(tickValues), _lodash2["default"].max(tickValues)];
      } else {
        return undefined;
      }
    }
  }, {
    key: "padDomain",
    value: function padDomain(domain, axis) {
      if (!this.props.domainPadding) {
        return domain;
      }
      var domainPadding = undefined;
      if (this.props.domainPadding[axis]) {
        domainPadding = this.props.domainPadding[axis];
      } else {
        domainPadding = _lodash2["default"].isNumber(this.props.domainPadding) ? this.props.domainPadding : 0;
      }
      if (domainPadding === 0) {
        return domain;
      }
      var domainMin = Math.min.apply(Math, _toConsumableArray(domain));
      var domainMax = Math.max.apply(Math, _toConsumableArray(domain));
      var rangeExtent = Math.abs(Math.max.apply(Math, _toConsumableArray(this.range[axis])) - Math.min.apply(Math, _toConsumableArray(this.range[axis])));
      var padding = Math.abs(domainMax - domainMin) * domainPadding / rangeExtent;
      // don't make the axes cross if they aren't already
      var adjustedMin = domainMin >= 0 && domainMin - padding <= 0 ? 0 : domainMin.valueOf() - padding;
      var adjustedMax = domainMax <= 0 && domainMax + padding >= 0 ? 0 : domainMax.valueOf() + padding;
      return _lodash2["default"].isDate(domainMin) || _lodash2["default"].isDate(domainMax) ? [new Date(adjustedMin), new Date(adjustedMax)] : [adjustedMin, adjustedMax];
    }
  }, {
    key: "getScale",
    value: function getScale(props, axis) {
      var baseScale = undefined;
      if (this.props.scale && this.props.scale[axis]) {
        // if scale is provided to chart, prefer it
        baseScale = this.props.scale[axis];
      } else if (this.props.scale && !_lodash2["default"].isObject(this.props.scale)) {
        baseScale = this.props.scale;
      } else {
        // otherwise use whatever scale the axis uses, (default: d3.scale.linear)
        baseScale = this.axisComponents[axis].props.scale;
      }
      var scale = baseScale.copy();
      scale.range(this.range[axis]);
      scale.domain(this.domain[axis]);
      return scale;
    }
  }, {
    key: "getAxisOffset",
    value: function getAxisOffset(props) {
      // make the axes line up, and cross when appropriate
      var origin = {
        x: _lodash2["default"].max([_lodash2["default"].min(this.domain.x), 0]),
        y: _lodash2["default"].max([_lodash2["default"].min(this.domain.y), 0])
      };
      var orientation = {
        x: this.axisOrientations.x || "bottom",
        y: this.axisOrientations.y || "left"
      };
      var orientationOffset = {
        x: orientation.y === "left" ? 0 : props.width,
        y: orientation.x === "bottom" ? props.height : 0
      };
      var calculatedOffset = {
        x: Math.abs(orientationOffset.x - this.scale.x.call(this, origin.x)),
        y: Math.abs(orientationOffset.y - this.scale.y.call(this, origin.y))
      };
      return {
        x: this.axisComponents.x.offsetX || calculatedOffset.x,
        y: this.axisComponents.y.offsetY || calculatedOffset.y
      };
    }
  }, {
    key: "getTickValues",
    value: function getTickValues(axis) {
      var stringMap = this.stringMap[axis];
      var ticksFromAxis = undefined;
      var ticksFromCategories = undefined;
      var ticksFromStringMap = undefined;
      // if tickValues are defined for an axis component use them
      if (this.axisComponents[axis].props.tickValues) {
        var axisTicks = this.axisComponents[axis].props.tickValues;
        ticksFromAxis = _victoryUtil.Collection.containsOnlyStrings(axisTicks) && stringMap ? _lodash2["default"].map(axisTicks, function (tick) {
          return stringMap[tick];
        }) : axisTicks;
      }
      if (!_lodash2["default"].isEmpty(this.groupedDataComponents) && axis === this.independentAxis) {
        // otherwise, create a set of tickValues base on groupedData categories
        var allCategoryTicks = _lodash2["default"].map(this.groupedDataComponents, function (component) {
          var categories = component.props.categories;
          return categories && _victoryUtil.Collection.isArrayOfArrays(categories) ? _lodash2["default"].map(categories, function (arr) {
            return _lodash2["default"].sum(arr) / arr.length;
          }) : categories;
        });
        var categoryTicks = _lodash2["default"].compact(_lodash2["default"].uniq(_lodash2["default"].flatten(allCategoryTicks)));
        var categoryArray = _lodash2["default"].isEmpty(categoryTicks) ? undefined : categoryTicks;
        ticksFromCategories = categoryArray && _victoryUtil.Collection.containsOnlyStrings(categoryArray) ? _lodash2["default"].map(categoryTicks, function (tick) {
          return stringMap[tick];
        }) : categoryArray;
      }
      if (stringMap) {
        // otherwise use the values from the string map
        ticksFromStringMap = _lodash2["default"].values(stringMap);
      }
      // when ticks is undefined, axis will determine it's own ticks
      return ticksFromAxis || ticksFromCategories || ticksFromStringMap;
    }
  }, {
    key: "getTickFormat",
    value: function getTickFormat(axis) {
      var _this10 = this;

      var tickFormat = this.axisComponents[axis].props.tickFormat;
      var tickValues = this.axisComponents[axis].props.tickValues;
      if (tickFormat) {
        return tickFormat;
      } else if (tickValues && !_victoryUtil.Collection.containsStrings(tickValues)) {
        return function (x) {
          return x;
        };
      } else if (this.stringMap[axis] !== null) {
        var _ret = (function () {
          var tickValueArray = _lodash2["default"].sortBy(_lodash2["default"].values(_this10.stringMap[axis]), function (n) {
            return n;
          });
          var invertedStringMap = _lodash2["default"].invert(_this10.stringMap[axis]);
          var dataNames = _lodash2["default"].map(tickValueArray, function (tick) {
            return invertedStringMap[tick];
          });
          // string ticks should have one tick of padding at the beginning
          var dataTicks = [""].concat(_toConsumableArray(dataNames), [""]);
          return {
            v: function (x) {
              return dataTicks[x];
            }
          };
        })();

        if (typeof _ret === "object") return _ret.v;
      } else {
        return this.scale[axis].tickFormat();
      }
    }
  }, {
    key: "generateData",
    value: function generateData(child) {
      var _this11 = this;

      if (!child.props.y) {
        return undefined;
      }
      var generateX = function generateX(component) {
        var domain = _this11.domain.x;
        var samples = _lodash2["default"].isArray(component.props.y) ? component.props.y.length : 50;
        var step = _lodash2["default"].max(domain) / samples;
        // return an array of x values spaced across the domain,
        // include the maximum of the domain
        return _lodash2["default"].union(_lodash2["default"].range(_lodash2["default"].min(domain), _lodash2["default"].max(domain), step), [_lodash2["default"].max(domain)]);
      };
      var y = child.props.y;
      var xArray = child.props.x || generateX(child);
      if (_lodash2["default"].isFunction(y)) {
        return _lodash2["default"].map(xArray, function (x) {
          return { x: x, y: y(x) };
        });
      } else {
        var n = _lodash2["default"].min([xArray.length, y.length]);
        return _lodash2["default"].map(_lodash2["default"].take(xArray, n), function (x, index) {
          return { x: x, y: y[index] };
        });
      }
    }
  }, {
    key: "getNewProps",
    value: function getNewProps(child) {
      var type = child.type && child.type.role;
      var animate = child.props.animate || this.props.animate;
      if (type === "axis") {
        var axis = child.props.dependentAxis ? this.dependentAxis : this.independentAxis;
        var offsetY = axis === "y" ? undefined : this.axisOffset.y;
        var offsetX = axis === "x" ? undefined : this.axisOffset.x;
        return {
          animate: animate,
          domain: this.domain[axis],
          scale: this.scale[axis],
          tickValues: this.tickValues[axis],
          tickFormat: this.tickFormat[axis],
          offsetY: offsetY,
          offsetX: offsetX,
          crossAxis: true
        };
      } else if (_lodash2["default"].includes(this.groupedDataTypes, type)) {
        var categoryAxis = this.independentAxis;
        var categories = this.stringMap[categoryAxis] && _lodash2["default"].keys(this.stringMap[categoryAxis]);
        return {
          animate: animate,
          domain: this.domain,
          scale: this.scale,
          categories: child.props.categories || categories
        };
      }
      var data = !child.props.data && child.props.y ? this.generateData(child) : undefined;
      return {
        data: data,
        animate: animate,
        domain: this.domain,
        scale: this.scale
      };
    }

    // the old ones were bad
  }, {
    key: "getNewChildren",
    value: function getNewChildren() {
      var _this12 = this;

      return _lodash2["default"].map(this.childComponents, function (child, index) {
        var style = _lodash2["default"].merge({}, { parent: _this12.style.parent }, child.props.style);
        var newProps = _this12.getNewProps(child);
        return _react2["default"].cloneElement(child, _lodash2["default"].merge({}, newProps, {
          height: _this12.props.height,
          width: _this12.props.width,
          padding: _this12.padding,
          ref: index,
          key: index,
          standalone: false,
          style: style
        }));
      });
    }
  }, {
    key: "render",
    value: function render() {
      this.getComponents(this.props);
      this.getCalculatedValues(this.props);
      var style = this.style.parent;
      var group = _react2["default"].createElement(
        "g",
        { style: style },
        this.getNewChildren()
      );
      return this.props.standalone ? _react2["default"].createElement(
        "svg",
        { style: style },
        group
      ) : group;
    }
  }], [{
    key: "propTypes",
    value: {
      /**
       * The animate prop specifies props for victory-animation to use. If this prop is
       * given, all children defined in chart will pass the options specified in this prop to
       * victory-animation, unless they have animation props of their own specified.
       * Large datasets might animate slowly due to the inherent limits of svg rendering.
       * @examples {velocity: 0.02, onEnd: () => alert("woo!")}
       */
      animate: _react2["default"].PropTypes.object,
      /**
       * The domain prop describes the range of values your chart will include. This prop can be
       * given as a array of the minimum and maximum expected values for your chart,
       * or as an object that specifies separate arrays for x and y.
       * If this prop is not provided, a domain will be calculated from data, or other
       * available information.
       * @examples: [-1, 1], {x: [0, 100], y: [0, 1]}
       */
      domain: _react2["default"].PropTypes.oneOfType([_react2["default"].PropTypes.array, _react2["default"].PropTypes.shape({
        x: _victoryUtil.PropTypes.domain,
        y: _victoryUtil.PropTypes.domain
      })]),
      /**
       * The domainPadding prop specifies a number of pixels of padding to add to the
       * beginning and end of a domain. This prop is useful for explicitly spacing ticks farther
       * from the origin to prevent crowding. This prop should be given as an object with
       * numbers specified for x and y.
       */
      domainPadding: _react2["default"].PropTypes.oneOfType([_react2["default"].PropTypes.shape({
        x: _victoryUtil.PropTypes.nonNegative,
        y: _victoryUtil.PropTypes.nonNegative
      }), _victoryUtil.PropTypes.nonNegative]),
      /**
       * The height props specifies the height of the chart container element in pixels
       */
      height: _victoryUtil.PropTypes.nonNegative,
      /**
       * The padding props specifies the amount of padding in number of pixels between
       * the edge of the chart and any rendered child components. This prop can be given
       * as a number or as an object with padding specified for top, bottom, left
       * and right.
       */
      padding: _react2["default"].PropTypes.oneOfType([_react2["default"].PropTypes.number, _react2["default"].PropTypes.shape({
        top: _react2["default"].PropTypes.number,
        bottom: _react2["default"].PropTypes.number,
        left: _react2["default"].PropTypes.number,
        right: _react2["default"].PropTypes.number
      })]),
      /**
       * The scale prop determines which scales your chart should use. This prop can be
       * given as a function, or as an object that specifies separate functions for x and y.
       * @examples d3.time.scale(), {x: d3.scale.linear(), y: d3.scale.log()}
       */
      scale: _react2["default"].PropTypes.oneOfType([_victoryUtil.PropTypes.scale, _react2["default"].PropTypes.shape({
        x: _victoryUtil.PropTypes.scale,
        y: _victoryUtil.PropTypes.scale
      })]),
      /**
       * The standalone prop determines whether the component will render a standalone svg
       * or a <g> tag that will be included in an external svg. Set standalone to false to
       * compose VictoryChart with other components within an enclosing <svg> tag.
       */
      standalone: _react2["default"].PropTypes.bool,
      /**
       * The style prop specifies styles for your chart. Victory Chart relies on Radium,
       * so valid Radium style objects should work for this prop. Height, width, and
       * padding should be specified via the height, width, and padding props, as they
       * are used to calculate the alignment of components within chart.
       * @examples {background: transparent, margin: 50}
       */
      style: _react2["default"].PropTypes.object,
      /**
       * The width props specifies the width of the chart container element in pixels
       */
      width: _victoryUtil.PropTypes.nonNegative
    },
    enumerable: true
  }, {
    key: "defaultProps",
    value: {
      height: 300,
      width: 450,
      padding: 50,
      standalone: true
    },
    enumerable: true
  }]);

  var _VictoryChart = VictoryChart;
  VictoryChart = (0, _radium2["default"])(VictoryChart) || VictoryChart;
  return VictoryChart;
})(_react2["default"].Component);

exports["default"] = VictoryChart;
module.exports = exports["default"];