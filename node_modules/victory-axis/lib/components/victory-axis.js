"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _radium = require("radium");

var _radium2 = _interopRequireDefault(_radium);

var _d3Scale = require("d3-scale");

var _d3Scale2 = _interopRequireDefault(_d3Scale);

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _victoryLabel = require("victory-label");

var _victoryAnimation = require("victory-animation");

var _axisLine = require("./axis-line");

var _axisLine2 = _interopRequireDefault(_axisLine);

var _grid = require("./grid");

var _grid2 = _interopRequireDefault(_grid);

var _tick = require("./tick");

var _tick2 = _interopRequireDefault(_tick);

var _victoryUtilLibPropTypes = require("victory-util/lib/prop-types");

var VictoryPropTypes = _interopRequireWildcard(_victoryUtilLibPropTypes);

var defaultStyles = {
  axis: {
    stroke: "#756f6a",
    fill: "none",
    strokeWidth: 2,
    strokeLinecap: "round"
  },
  axisLabel: {
    stroke: "transparent",
    fill: "#756f6a",
    fontSize: 16,
    fontFamily: "Helvetica"
  },
  grid: {
    stroke: "#c9c5bb",
    fill: "none",
    strokeWidth: 0,
    strokeLinecap: "round"
  },
  ticks: {
    stroke: "#756f6a",
    fill: "none",
    padding: 5,
    strokeWidth: 2,
    strokeLinecap: "round",
    size: 4
  },
  tickLabels: {
    stroke: "transparent",
    fill: "#756f6a",
    fontFamily: "Helvetica",
    fontSize: 10,
    padding: 5
  }
};

var orientationSign = {
  top: -1,
  left: -1,
  right: 1,
  bottom: 1
};

var orientationVerticality = {
  top: false,
  bottom: false,
  left: true,
  right: true
};

var VictoryAxis = (function (_React$Component) {
  _inherits(VictoryAxis, _React$Component);

  function VictoryAxis() {
    _classCallCheck(this, _VictoryAxis);

    _get(Object.getPrototypeOf(_VictoryAxis.prototype), "constructor", this).apply(this, arguments);
  }

  _createClass(VictoryAxis, [{
    key: "getCalculatedValues",
    value: function getCalculatedValues(props) {
      // order matters!
      this.style = this.getStyles(props);
      this.padding = this.getPadding(props);
      this.orientation = this.getOrientation(props);
      this.isVertical = orientationVerticality[this.orientation];
      this.stringTicks = this.props.tickValues && typeof this.props.tickValues[0] === "string";
      this.range = this.getRange(props);
      this.domain = this.getDomain(props);
      this.scale = this.getScale(props);
      this.ticks = this.getTicks(props);
      this.labelPadding = this.getLabelPadding(props);
      this.offset = this.getOffset(props);
      this.transform = this.getTransform(props);
    }
  }, {
    key: "getOrientation",
    value: function getOrientation(props) {
      return props.orientation || (props.dependentAxis ? "left" : "bottom");
    }
  }, {
    key: "getStyles",
    value: function getStyles(props) {
      var style = props.style || {};
      var parentStyleProps = { height: props.height, width: props.width };
      return {
        parent: _lodash2["default"].merge(parentStyleProps, defaultStyles.parent, style.parent),
        axis: _lodash2["default"].merge({}, defaultStyles.axis, style.axis),
        axisLabel: _lodash2["default"].merge({}, defaultStyles.axisLabel, style.axisLabel),
        grid: _lodash2["default"].merge({}, defaultStyles.grid, style.grid),
        ticks: _lodash2["default"].merge({}, defaultStyles.ticks, style.ticks),
        tickLabels: _lodash2["default"].merge({}, defaultStyles.tickLabels, style.tickLabels)
      };
    }
  }, {
    key: "getPadding",
    value: function getPadding(props) {
      var padding = props.padding || 0;
      if (typeof padding === "number") {
        return {
          top: padding,
          right: padding,
          bottom: padding,
          left: padding
        };
      }
      return {
        top: padding.top || 0,
        right: padding.right || 0,
        bottom: padding.bottom || 0,
        left: padding.left || 0
      };
    }
  }, {
    key: "getDomain",
    value: function getDomain(props) {
      if (props.domain) {
        return props.domain;
      } else if (props.tickValues) {
        return this._getDomainFromTickValues(props);
      }
      return this._getDomainFromScale(props);
    }

    // helper for getDomain()
  }, {
    key: "_getDomainFromTickValues",
    value: function _getDomainFromTickValues(props) {
      var domain = undefined;
      // Since we declared that `tickValues` must be a homogenous array, we only
      // need to do a string check on the first item.
      if (this.stringTicks) {
        domain = [1, props.tickValues.length];
      } else {
        // coerce ticks to numbers
        var ticks = _lodash2["default"].map(props.tickValues, Number);
        domain = [_lodash2["default"].min(ticks), _lodash2["default"].max(ticks)];
      }
      if (this.isVertical) {
        domain.reverse();
      }
      return domain;
    }

    // helper for getDomain()
  }, {
    key: "_getDomainFromScale",
    value: function _getDomainFromScale(props) {
      return props.scale.domain();
    }
  }, {
    key: "getRange",
    value: function getRange(props) {
      return this.isVertical ? [props.height - this.padding.bottom, this.padding.top] : [this.padding.left, props.width - this.padding.right];
    }
  }, {
    key: "getScale",
    value: function getScale(props) {
      var scale = props.scale.copy();
      scale.range(this.range);
      scale.domain(this.domain);
      return scale;
    }
  }, {
    key: "getTicks",
    value: function getTicks(props) {
      if (props.tickValues) {
        // Since we declared that `tickValues` must be a homogenous array, we only
        // need to do a string check on the first item.
        if (this.stringTicks) {
          return _lodash2["default"].range(1, props.tickValues.length + 1);
        }
        return props.tickValues;
      } else if (_lodash2["default"].isFunction(this.scale.ticks)) {
        var ticks = this.scale.ticks(props.tickCount);
        if (props.crossAxis) {
          return _lodash2["default"].includes(ticks, 0) ? _lodash2["default"].without(ticks, 0) : ticks;
        }
        return ticks;
      }
      return this.scale.domain();
    }
  }, {
    key: "getTickFormat",
    value: function getTickFormat(props) {
      if (props.tickFormat && _lodash2["default"].isFunction(props.tickFormat)) {
        return props.tickFormat;
      } else if (props.tickFormat && _lodash2["default"].isArray(props.tickFormat)) {
        return function (x, index) {
          return props.tickFormat[index];
        };
      } else if (this.stringTicks) {
        return function (x, index) {
          return props.tickValues[index];
        };
      } else if (_lodash2["default"].isFunction(this.scale.tickFormat())) {
        return this.scale.tickFormat(this.ticks.length);
      } else {
        return _lodash2["default"].identity;
      }
    }
  }, {
    key: "getLabelPadding",
    value: function getLabelPadding(props) {
      var style = this.style.axisLabel;
      if (typeof style.padding !== "undefined" && style.padding !== null) {
        return style.padding;
      }
      // TODO: magic numbers
      return props.label ? style.fontSize * (this.isVertical ? 2.3 : 1.6) : 0;
    }
  }, {
    key: "getOffset",
    value: function getOffset(props) {
      var xPadding = props.orientation === "right" ? this.padding.right : this.padding.left;
      var yPadding = props.orientation === "top" ? this.padding.top : this.padding.bottom;
      var fontSize = this.style.axisLabel.fontSize;
      var offsetX = props.offsetX || xPadding;
      var offsetY = props.offsetY || yPadding;
      var totalPadding = fontSize + 2 * this.style.ticks.size + this.labelPadding;
      var minimumPadding = 1.2 * fontSize; // TODO: magic numbers
      var x = this.isVertical ? totalPadding : minimumPadding;
      var y = this.isVertical ? minimumPadding : totalPadding;
      return {
        x: offsetX || x,
        y: offsetY || y
      };
    }
  }, {
    key: "getTransform",
    value: function getTransform(props) {
      var translate = ({
        top: [0, this.offset.y],
        bottom: [0, props.height - this.offset.y],
        left: [this.offset.x, 0],
        right: [props.width - this.offset.x, 0]
      })[this.orientation];
      return "translate(" + translate[0] + ", " + translate[1] + ")";
    }
  }, {
    key: "renderLine",
    value: function renderLine(props) {
      return _react2["default"].createElement(_axisLine2["default"], { key: "line",
        style: this.style.axis,
        x1: this.isVertical ? null : this.padding.left,
        x2: this.isVertical ? null : props.width - this.padding.right,
        y1: this.isVertical ? this.padding.top : null,
        y2: this.isVertical ? props.height - this.padding.bottom : null
      });
    }
  }, {
    key: "renderTicks",
    value: function renderTicks(props) {
      var _this = this;

      var tickFormat = this.getTickFormat(props);
      return _lodash2["default"].map(this.ticks, function (tick, index) {
        var position = _this.scale(tick);
        return _react2["default"].createElement(_tick2["default"], { key: "tick-" + index,
          position: position,
          tick: _this.stringTicks ? props.tickValues[tick - 1] : tick,
          orientation: _this.orientation,
          label: tickFormat.call(_this, tick, index),
          style: {
            ticks: _this.style.ticks,
            tickLabels: _this.style.tickLabels
          }
        });
      });
    }
  }, {
    key: "renderGrid",
    value: function renderGrid(props) {
      var _this2 = this;

      var xPadding = this.orientation === "right" ? this.padding.right : this.padding.left;
      var yPadding = this.orientation === "top" ? this.padding.top : this.padding.bottom;
      var sign = -orientationSign[this.orientation];
      var xOffset = props.crossAxis ? this.offset.x - xPadding : 0;
      var yOffset = props.crossAxis ? this.offset.y - yPadding : 0;
      var x2 = this.isVertical ? sign * (props.width - (this.padding.left + this.padding.right)) : 0;
      var y2 = this.isVertical ? 0 : sign * (props.height - (this.padding.top + this.padding.bottom));
      return _lodash2["default"].map(this.ticks, function (tick, index) {
        // determine the position and translation of each gridline
        var position = _this2.scale(tick);
        return _react2["default"].createElement(_grid2["default"], { key: "grid-" + index,
          tick: _this2.stringTicks ? _this2.props.tickValues[tick - 1] : tick,
          x2: x2,
          y2: y2,
          xTransform: _this2.isVertical ? -xOffset : position,
          yTransform: _this2.isVertical ? position : yOffset,
          style: _this2.style.grid
        });
      });
    }
  }, {
    key: "renderLabel",
    value: function renderLabel(props) {
      if (!props.label) {
        return undefined;
      }

      var sign = orientationSign[this.orientation];
      var hPadding = this.padding.left + this.padding.right;
      var vPadding = this.padding.top + this.padding.bottom;
      var x = this.isVertical ? -((props.height - vPadding) / 2) - this.padding.top : (props.width - hPadding) / 2 + this.padding.left;
      var newProps = {
        key: "label",
        x: x,
        y: sign * this.labelPadding,
        textAnchor: "middle",
        verticalAnchor: sign < 0 ? "end" : "start",
        style: this.style.axisLabel,
        transform: this.isVertical ? "rotate(-90)" : ""
      };
      return props.label.props ? _react2["default"].cloneElement(props.label, newProps) : _react2["default"].createElement(_victoryLabel.VictoryLabel, newProps, props.label);
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      // If animating, return a `VictoryAnimation` element that will create
      // a new `VictoryAxis` with nearly identical props, except (1) tweened
      // and (2) `animate` set to null so we don't recurse forever.
      if (this.props.animate) {
        // Do less work by having `VictoryAnimation` tween only values that
        // make sense to tween. In the future, allow customization of animated
        // prop whitelist/blacklist?
        var animateData = _lodash2["default"].pick(this.props, ["style", "domain", "range", "tickCount", "tickValues", "labelPadding", "offsetX", "offsetY", "padding", "width", "height"]);
        return _react2["default"].createElement(
          _victoryAnimation.VictoryAnimation,
          _extends({}, this.props.animate, { data: animateData }),
          function (props) {
            return _react2["default"].createElement(VictoryAxis, _extends({}, _this3.props, props, { animate: null }));
          }
        );
      } else {
        this.getCalculatedValues(this.props);
      }
      var group = _react2["default"].createElement(
        "g",
        { style: this.style.parent, transform: this.transform },
        this.renderLabel(this.props),
        this.renderTicks(this.props),
        this.renderLine(this.props),
        this.renderGrid(this.props)
      );
      return this.props.standalone ? _react2["default"].createElement(
        "svg",
        { style: this.style.parent },
        group
      ) : group;
    }
  }], [{
    key: "role",
    value: "axis",
    enumerable: true
  }, {
    key: "propTypes",
    value: {
      /**
       * The animate prop specifies props for victory-animation to use. It this prop is
       * not given, the axis will not tween between changing data / style props.
       * Large datasets might animate slowly due to the inherent limits of svg rendering.
       * @examples {velocity: 0.02, onEnd: () => alert("done!")}
       */
      animate: _react.PropTypes.object,
      /**
       * This prop specifies whether a given axis is intended to cross another axis.
       */
      crossAxis: _react.PropTypes.bool,
      /**
       * The dependentAxis prop specifies whether the axis corresponds to the
       * dependent variable (usually y). This prop is useful when composing axis
       * with other components to form a chart.
       */
      dependentAxis: _react.PropTypes.bool,
      /**
       * The domain prop describes the range of values your axis will include. This prop should be
       * given as a array of the minimum and maximum expected values for your axis.
       * If this value is not given it will be calculated based on the scale or tickValues.
       * @examples [-1, 1]
       */
      domain: VictoryPropTypes.domain,
      /**
       * The height prop specifies the height of the chart container element in pixels.
       */
      height: VictoryPropTypes.nonNegative,
      /**
       * The label prop specifies the label for your axis. This prop can be a string or
       * a label component.
       */
      label: _react.PropTypes.any,
      /**
       * The labelPadding prop specifies the padding in pixels for your axis label.
       */
      labelPadding: _react.PropTypes.number,
      /**
       * This value describes how far from the "edge" of its permitted area each axis
       * will be set back in the x-direction.  If this prop is not given,
       * the offset is calculated based on font size, axis orientation, and label padding.
       */
      offsetX: _react.PropTypes.number,
      /**
       * This value describes how far from the "edge" of its permitted area each axis
       * will be set back in the y-direction.  If this prop is not given,
       * the offset is calculated based on font size, axis orientation, and label padding.
       */
      offsetY: _react.PropTypes.number,
      /**
       * The orientation prop specifies the position and orientation of your axis.
       */
      orientation: _react.PropTypes.oneOf(["top", "bottom", "left", "right"]),
      /**
       * The padding props specifies the amount of padding in number of pixels between
       * the edge of the chart and any rendered child components. This prop can be given
       * as a number or as an object with padding specified for top, bottom, left
       * and right.
       */
      padding: _react.PropTypes.oneOfType([_react.PropTypes.number, _react.PropTypes.shape({
        top: _react.PropTypes.number,
        bottom: _react.PropTypes.number,
        left: _react.PropTypes.number,
        right: _react.PropTypes.number
      })]),
      /**
       * The scale prop determines which scales your axis should use. This prop should be
       * given as a function.
       * @examples d3Scale.time()
       */
      scale: VictoryPropTypes.scale,
      /**
       * The standalone prop determines whether the component will render a standalone svg
       * or a <g> tag that will be included in an external svg. Set standalone to false to
       * compose VictoryAxis with other components within an enclosing <svg> tag.
       */
      standalone: _react.PropTypes.bool,
      /**
       * The style prop specifies styles for your chart. Victory Axis relies on Radium,
       * so valid Radium style objects should work for this prop, however height, width, and margin
       * are used to calculate range, and need to be expressed as a number of pixels.
       * Styles for axis lines, gridlines, and ticks are scoped to separate props.
       * @examples {axis: {stroke: "#756f6a"}, grid: {stroke: "grey"}, ticks: {stroke: "grey"},
       * tickLabels: {fontSize: 10, padding: 5}, axisLabel: {fontSize: 16, padding: 20}}
       */
      style: _react.PropTypes.shape({
        parent: _react.PropTypes.object,
        axis: _react.PropTypes.object,
        axisLabel: _react.PropTypes.object,
        grid: _react.PropTypes.object,
        ticks: _react.PropTypes.object,
        tickLabels: _react.PropTypes.object
      }),
      /**
       * The tickCount prop specifies how many ticks should be drawn on the axis if
       * tickValues are not explicitly provided.
       */
      tickCount: VictoryPropTypes.nonNegative,
      /**
       * The tickFormat prop specifies how tick values should be expressed visually.
       * tickFormat can be given as a function to be applied to every tickValue, or as
       * an array of display values for each tickValue.
       * @examples d3.time.format("%Y"), (x) => x.toPrecision(2), ["first", "second", "third"]
       */
      tickFormat: _react.PropTypes.oneOfType([_react.PropTypes.func, VictoryPropTypes.homogeneousArray]),
      /**
       * The tickValues prop explicitly specifies which tick values to draw on the axis.
       * @examples ["apples", "bananas", "oranges"], [2, 4, 6, 8]
       */
      tickValues: VictoryPropTypes.homogeneousArray,
      /**
       * The width props specifies the width of the chart container element in pixels
       */
      width: VictoryPropTypes.nonNegative
    },
    enumerable: true
  }, {
    key: "defaultProps",
    value: {
      height: 300,
      padding: 50,
      scale: _d3Scale2["default"].linear(),
      standalone: true,
      tickCount: 5,
      width: 450
    },
    enumerable: true
  }]);

  var _VictoryAxis = VictoryAxis;
  VictoryAxis = (0, _radium2["default"])(VictoryAxis) || VictoryAxis;
  return VictoryAxis;
})(_react2["default"].Component);

exports["default"] = VictoryAxis;
module.exports = exports["default"];